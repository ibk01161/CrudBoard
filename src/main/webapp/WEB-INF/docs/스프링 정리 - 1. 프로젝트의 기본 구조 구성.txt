PART1. 프로젝트의 기본 구조 구성
#1. 개발 환경의 설정

* 스프링 프로젝트를 시작하는 두 가지 방법
1) Spring Boot 이용 - 별도 설정이 필요X, WAS (웹서버 ex. Tomcat) 없이 실행 가능, 로딩 시간 짧아 테스트 하기 편함, 기존설정과 다른방식, JSP 설정 등은 별도로 해야 함
2) 스프링 템플릿 프로젝트 이용 (Spring Legacy Project) - 실무에서 많이 사용, 다양한 자료, 기존 플젤을 이해하는데 도움이 됨, 모든 버전의 스프링에서 사용가능, 초반 환경 구성 어렵, WAS와 연동시 결과 확인에 많은 리소스 소모

* Maven - 프로젝트 관리 도구, 프로젝트의 시작과 끝까지의 단계에 맞춰 사용하는 개발 도구
            - 플젝에 필요한 의존적인 라이브러리를 자동으로 관리해 주는 용도로 많이 사용
            - 다운로드 받은 라이브러리 사용하는 경로는 '.m2' 폴더

* 스프링 MVC 프로젝트 템플릿의 구조
- src/main/java : 개발되는 Java코드의 경로
- src/main/resources : 서버가 실행될 때 필요한 파일들의 경로
- src/test/java : 테스트 전용 경로 (각 테스트 코드 작성 경로)
- src/test/resouces : 테스트 시에만 사용되는 파일들 경로
- scr/main/webapp/resources/WEB-INF/spring : Sprnig 설정 파일의 경로
- scr/main/webapp/resources/WEB-INF/views : JSP 파일의 경로
- src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml : 스프링 MVC 관련 설정만을 분리하기 위해서 만들어진 파일
- src/main/webapp/WEB-INF/spring/root-context.xml : 웹 자원과 관련되지 않은 모든 자원의 설정을 위해 존재, Namespaces 탭을 이용해 사용 가능한 XML 태그의 폭을 넓힐 수 있음
- pom.xml : Maven의 설정 파일

#2. 스프링에 대한 간단 소개

* 스프링 프레임워크의 장점 - 개발에 필요한 구조를 이미 코드로 만들어 놓았기 때문에, 필요 부분을 조립하는 형태의 개발 가능, 개발 시간 단축
		          - 프로젝트의 전체 구조를 설계할 때 유용함
		          - 기본 뼈대를 흔들지 않고, 여러 종류의 프레임워크를 혼용해서 사용 가능
		          - 2.5v에 애노테이션을 활용하는 설정 도입하면서 편리한 설정과 개발 가능, 4.0v에 REST 방식의 컨트롤러 지원

* 스프링의 주요 특징
1) POJO(Plain Old Java Object) 기반의 구성 - 일반적인 Java코드를 이용해서 객체를 구성하는 방식을 그대로 스프링에서 사용할 수 있음
				   - 코드를 개발할 때 개발자가 특정한 라이브러리나 컨테이너의 기술에 종속적이지 않음
				   - 가장 일반적인 코드를 작성하고, 실행할 수 있기 때문에 생산성 유리, 코드에 대한 테스트 작업 역시 유연하게 할 수 있음

2) 의존성 주입(DI- Dependency Injection)을 통한 객체 각의 관계 구성 - 제어의 역행이 일어날 때 스프링이 내부에 있는 객체(Bean)들 간의 관계를 관리할 때 사용하는 기법
						          - 의존성이란? 어떤 객체가 혼자 일을 처리할 수 없다는 것을 의미, 객체 A가 B의 도움을 받아야 온전히 일을 처리할 수 있을 때 'A는 B에 의존적이다'라고 표현
						          - Java에서는 인터페이스를 이용해 이런 의존적인 객체의 관계를 유연하게 처리할 수 있도록 노력함
						          - 제어의 역행으로 특성 객체에 필요한 객체를 외부에서 결정해서 연결 시키는 것, 인터페이스를 활용해 유연한 구조를 사용할 수 있음
						          - 스프링은 프레임워크에서 처리하기 때문에 자신이 만드는 객체나 클래스 외에는 신경 쓰지 않고 코드를 만들고, 코드에 필요한 객체는 스프링을 통해 주입
						          - 의존성 주입 종류로 생성자를 통한 주입, set 메소드를 이용한 주입으로 구분할 수 있음, 이에 대한 처리는 간단한 어노테이션만으로 처리 가능

* IoC(Inversion Of Control - 제어의 역행) - 메소드나 객체의 호출작업을 개발자가 결정하는 것이 아니라, 외부에서 결정되는 것

3) AOP(Aspect-Oriented-Programming) 지원 - 반복적인 코드를 줄이고, 핵심 비즈니스 로직에만 집중할 수 있는 방법 제공
				    - 대부분 시스템 공통으로 가지는 보안이나 로그, 트랜잭션과 같이 비즈니스 로직은 아니지만, 반드시 처리가 필요한 부분을 '횡단 관심사(cross-concern)'라고 함
				    - 횡단 관심사를 분리해서 제작하는 것이 가능, AOP는 이러한 횡단 관심사를 모듈로 분리하는 프로그래밍의 패러다임, AspectJ의 문법을 통해 작성 가능
				    =>핵심 비즈니스 로직에만 집중해서 코드를 개발할 수 있고, 각 플젝마다 다른 관심사를 적용할 때 코드의 수정을 최소화, 원하는 관심사의 유지보수가 수월한 코드 구성 가능
4) 편리한 MVC 구조
5) WAS에 종속적이지 않은 개발 환경
6) 트랜잭션 지원 - 데이터베이스를 이용할 때 어노테이션이나 XML 파일로 설정 가능

#4. 스프링 + MyBatis + MySQL 설정

* 일반적인 스프링 웹 프로젝트의 구성
1) Presentation Layer - UI를 담당하는 구성 요소, 웹인지 모바일 앱인지에 따라 사용되는 기술이 변경됨, JSP와 같은 뷰(View)를 구성하는 부분과 Controller라는 부분으로 분리되어서 작성
2) Business Layer - 서비스 계층, 고객의 요구사항을 반영하는 계층, 사용자의 환경이 아닌 기능적인 요구사항을 구현한 곳, 비즈니스 계층은 어떤 형태의 데이터가 필요하고, 반환될 것인가를 결정
3) Data Access Layer(Persistence Layer) - 데이터 처리를 전문으로 담당, MyBatis추가, MyBatis를 호출하고 사용하는 구조로 만들어짐

* MyBaits의 장점

1) 간결한 코드의 처리 - SQL Mapper 라이브러리, JDBC로 작업을 하게 되면 개발자는 많은 코드를 반복하게됨(try ~ catch ~ finally 부터 PreparedStatement와 ResultSet)
		  - 이러한 코드를 상당히 많이 줄여 줄 수 있기 때문에 개발의 속도를 향상시킴, 스프링과 MyBatis와 결합하게 되면 코드 제작 없이도 JDBC의 처리 가능
2) SQL 문의 분리운영 - JDBC는 SQL문을 처리하기 위해 별도의 파일을 작성하는 등의 번거로운 작업이 필요
		  - XML 혹은 어노테이션 방식으로 SQL문을 별도로 처리하는 작업 가능, 두 가지 방식 혼합해 사용 가능
3) Spring과의 연동으로 자동화된 처리 - 스프링과 MyBatis를 연계하는 MyBatis-Spring 라이브러리를 이용하면 개발자는 직접 SQL문의 호출 없이도 원하는 결과를 얻을 수 있음
			         - MyBatis-Spring 라이브러리가 만들어내는 클래스 덕분에 MyBatis 단독으로 사용하는 것보다는 스프링과 연계해서 사용하는 편이 오히려 코드의 양을 줄여주게 됨
4) 동적 SQL을 이용한 제어 가능 - MyBatis는 기본적으로 SQL문을 처리하기는 하지만, 약가느이 제어문이나 루프 등의 처리 기능을 가지고 있음
			  - SQL과 관련된 처리를 Java코드에서 분리시킬 수 있음

* MyBatis 연동 방법
1) pom.xml을 이용해 필요한 jar 파일을 다운로드
2) root-context.xml 파일 수정 (네임스페이스 추가)
3) MySQL과 연결을 담당하는 DataSource 설정 (root-context.xml에서 DataSource추가)
4) DataSource의 테스트 진행 (spring-test 모듈의 도움을 받아 테스트, JUnit v4.11 이상 사용)
5) MyBatis와 MySQL을 연동 (SqlSessionFactory 객체 설정, MyBatis와 스프링 연동 작업에서 핵심은 Connection을 생성하고, 처리하는 SqlSessionFactory의 존재, 데이터베이스와의 연결과 SQL의 실행에 대한 모든것을 가진 중요한 객체)
6) SqlSessionFactory를 생성해 주는 특별한 객체 설정 (root-context.xml 에서 SqlSessionFactoryBean 등록)
7) mybatis-config.xml 파일 추가 (MyBatis는 SQL Mapping 프레임워크로 별도 설정 파일을 가질 수 있음, 스프링의 설정과 별도로 사용하는 모든 MyBatis의 설저 기능을 활용할 수 있음)
8) MyBatis와 MySQL 연결 확인

#5. 모델2 방식과 스프링 MVC

* 모델2 패턴이란?
- MVC 구조를 응용한 방식, 화면과 데이터 처리를 분리해서 재사용이 가능하도록 하는 구조
- 모델(Model) : 데이터 혹은 데이터를 처리하는 영역
- 뷰(View) : 결과 화면을 만들어 내는 데 사용하는 자원(JSP)
- 컨트롤러(Controller) : 웹의 요청(request)을 처리하는 존재로 뷰와 모델 사이의 중간 통신 역할
- 컨트롤러는 모델 계층과 연동해서 필요한 데이터를 처리하고 결과를 뷰로 전송하게 됨, 모든 요청은 기본적으로 컨트롤러를 호출, 각 컨트롤러는 자신을 호출하는 특정한 URI 경로를 가지고 있음
- 개발자와 웹 퍼블리셔의 영역을 분리할 수 있음, 컨트롤러의 URI를 통해서 뷰를 제어하기 때문에, 뷰의 교체나 변경과 같은 유지보수에 유용하게 사용

* Front Controller 패턴
- 각 컨트롤러 사이의 중복적인 코드의 문제와 개발자의 개발 패턴의 차이 등의 문제로 인해 모델2 방식은 좀 더 강제적인 형태인 Front Controller 방식을 적용
- 전체 로직의 일부만을 컨트롤러가 처리하도록 변경, '위임(Delegation)' 이라고 하는데, 전체 로직의 일부를 컨트롤러에게 위임하고 모든 흐름의 제어는 앞쪽의 Front Controller가 담당
- 컨트롤러는 전체 로직의 일부분만을 처리하는 형태가 되기 때문에 개발자가 작성해야 하는 전체 코드는 줄어들게됨
- 모든 컨트롤러는 Front Controller의 일부분을 구현하는 형태이므로 좀 더 규격화된 코드를 작성하게 됨

* 스프링 MVC 구조
1) 사용자의 모든 요청은 스프링 MVC의 Front Controller에게 전달됨
2) 전달된 요청은 적절한 컨트롤러를 찾아 호출하게 됨
3) 컨트롤러는 적절한 서비스 객체를 찾아서 호출하고, 서비스는 데이터베이스의 작업을 담당하는 DAO(Data Access Object)를 이용해 원하는 데이터를 요청하게 됨
4) DAO 객체는 MyBatis를 이용하는 Mapper를 통해 원하는 작업을 수행
5) 서비스가 처리한 데이터를 컨트롤러에게 전달
6) 컨트롤러는 다시 스프링 MVC쪽으로 데이터를 전달하게 됨

* 스프링 MVC가 처리해 주는 작업 - URI를 분석해서 적절한 컨트롤러를 찾는 작업, 컨트롤러에 필요한 메소드를 호출하는 작업
			     - 컨트롤러의 결과 데이터를 뷰로 전달하는 작업, 적절한 뷰를 찾는 작업

* 개발자가 직접 해야 하는 작업 - 특정 URI에 동작하는 컨트롤러를 설계하는 작업
			 - 서비스 객체, DAO 객체 생성
			 - 컨트롤러 내에 원하는 결과를 메소드로 설계, 뷰에서 전달받은 데이터의 출력

* 스프링 MVC 컨트롤러가 처리해 주는 것
- 파라미터 수집 : 웹에서 가장 많이 하는 작업은 사용자의 요청(request)에 필요한 데이터를 추출, 이를 VO(Value Object) 혹은 DTO(Data Transfer Object)로 변환하는 파라미터의 수집 작업 => 이러한 처리를 자동으로 해줌
- 어노테이션을 통한 간편 설정 : 클래스나 메소드의 선언에 필요한 어노테이션을 추가하는 작업을 통해 요청(request)이나 응답(response)에 필요한 모든 처리를 완료할 수 있음
- 로직의 집중 : 각 메소드마다 필요한 어노테이션을 설정할 수 있기 때문에 여러 메소드를 하나의 컨트롤러에 집중해서 작성할 수 있음
- 테스트의 편리함 : 테스트 모듈을 사용해 스프링 MVC로 작성된 코드를 WAS의 실행 없이도 테스트할 수 있음

* 스프링 MVC 컨트롤러의 독특한 점
- 상속이나 인터페이스를 구현하지 않아도 됨, 대신 '@Controller' 라는 어노테이션에 대한 추가 작업을 함
- 메소드의 파라미터와 리턴 타입에 대한 제약이 없어 기존보다 훨씬 자유로운 코드를 만들어 낼 수 있음
- 스프링 MVC가 제공하는 유용한 클래스들이 존재, 다양한 클래스를 이용해 필요한 작업을 수월하게 진행할 수 있음 (ex 파일 업로드 처리, 유효성 검사 등)

* 스프링 MVC에서 주로 사용하는 어노테이션의 종류
*1) @Controller - 스프링 MVC의 컨트롤러 객체임을 명시하는 어노테이션 (클래스에서 사용)
*2) @RequestMapping - 특정 URI에 매칭되는 클래스나 메소드임을 명시하는 어노테이션 (클래스, 메소드에서 사용), 특정한 URI 경로에 해당하면 메소드가 실행
3) @RequestParam - 요청(request)에서 특정한 파라미터의 값을 찾아낼 때 사용하는 어노테이션 (파라미터에서 사용)
4) @RequestHeader - 요청(request)에서 특정 HTTP 헤더 정보를 추출할 때 사용 (파라미터에서 사용)
5) @PathVariable - 현재 URI에서 원하는 정보를 추출할 때 사용하는 어노테이션 (파라미터에서 사용)
6) @CookieValue - 현재 사용자의 쿠키가 존재하는 경우 쿠키의 이름을 이용해서 쿠키의 값을 추출 (파라미터에서 사용)
7) @ModelAttribute - 자동으로 해당 객체를 뷰까지 전달하도록 만드는 어노테이션 (메소드, 파라미터에서 사용)
8) @SessionAttribute - 세션상에서 모델의 정보를 유지하고 싶은 경우에 사용 (클래스에서 사용)
9) @InitBinder - 파라미터를 수집해서 객체로 만들 경우에 커스터마이징 (메소드에서 사용)
10) @ResponseBody - 리턴 타입이 HTTP의 응답 메시지로 전송 (메소드, 리턴타입에서 사용)
11) @RequestBody - 요청(request) 문자열이 그대로 파라미터로 전달 (파라미터에서 사용)
12) @Repository - DAO 객체 (클래스에서 사용)
13) @Service - 서비스 객체 (클래스에서 사용)

* 컨트롤러 생성 (Ex00_jUnittest project)
1) void 리턴 타입의 경우 - 현재 메소드의 리턴 타입이 void인 경우에는 스프링 MVC는 현재 경로에 해당하는 JSP 파일을 실행하게 됨 (SampleController.Java)
2) String 리턴 타입인 경우 - 메소드의 리턴 타입이 문자열인 경우에 결과는 '문자열+.jsp' 파일을 찾아서 실행하게 됨, 메소드의 리턴 값으로 사용된 이름.jsp 파일을 찾아 실행 (SampleController2.Java)
3) 만들어진 결과 데이터를 전달해야 하는 경우 (Model 객체 사용) - 다른 객체의 도움을 받아 만들어진 데이터를 뷰로 전달하는 일, Model 객체 사용, 필요한 데이터를 담은 후 뷰로 전달 (SampleController3.Java)
						    - Model 클래스는 MVC에서 기본적으로 제공되는 클래스, 뷰에 원하는 데이터를 전달하는 일종의 컨테이너나 상자의 역할
						    - addAttribute()메소드를 이용해 객체 보관
						    - addAttribute("이름","객체") : 객체에 특별한 이름을 부여해 뷰에서 이름값을 이용해 객체 처리
						    - addAttribute(객체) : 이름을 지정하지 않는 경우에는 자동으로 저장되는 객체의 클래스명 앞 글자를 소문자로 처리한 클래스명을 이름으로 간주
4) 리다이렉트를 해야 하는 경우 - 특정한 컨트롤러의 로직을 처리할 때 다른 경로를 호출해야 하는 경우에 'redifect:'를 사용 (SampleController4.Java)
			 - RedirectAttribute라는 클래스를 파라미터로 같이 사용하게 되면 리다이렉트 시점에 원하는 데이터를 임시로 추가해서 넘기는 작업이 가능
5) JSON 데이터를 생성하는 경우 - 적절한 객체를 반환해 주고, @ResponseBody 어노테이션을 추가 (SampleController5.Java)

#6. 스프링 + MyBatis

* MyBatis란?
- JDBC에서 개발자가 직접 처리하는 PreparedStatement의 '?'에 대한 설정리나 ResultSet을 이용한 처리가 이루어지기 때문에 기존 방식에 비해 개발의 생산성이 좋아짐
- 어노테이션을 지원하고, 인터페이스와 어노테이션을 통해 SQL 문을 설정하고 처리할 수 있는 형태로 발전

* MyBatis를 이용할 때 SQL 문을 사용하는 방식 (대부분 1번방식 선호)
**1) XML만을 이용해 SQL문을 설정, DAO에서는 XML을 찾아서 실행하는 코드를 작성하는 방식 
장점 : SQL문은 별도의 XML로 작성되기 때문에 SQL문의 수정이나 유지보수에 적합
단점 : 개발 시 코드의 양이 많아지고, 복잡성이 증가
2) 어노테이션과 인터페이스만을 이용해 SQL문을 설정
장점 : 별도의 DAO없이도 개발이 가능하기 때문에 생산성이 크게 증가
단점 : SQL 문을 어노테이션으로 작성하므로, 매번 수정이 일어나는 경우 다시 컴파일
3) 인터페이스와 XML로 작성된 SQL문의 활용
장점 : 간단한 SQL문은 어노테이션으로 복잡한 SQL문은 XML로 처리하므로, 상황에 따라서 유연하게 처리
단점 : 개발자에 따라 개발 방식의 차이가 있을 수 있기 때문에, 유지보수가 중요한 프로젝트의 경우 부적합

* MyBatis를 XML을 사용해 작성하는 경우 코딩 순서
1) 테이블 생성 및 개발 준비, 테이블 생성 및 기타 데이터베이스 관련 설정
2) 도메인 객체의 설계 및 클래스 작성 - 도메인이란 하나의 온전한 시스템의 단위, 여러 물리적인 환경으로 분리가 가능한 단위, 예를 들어 회원, 상품, 배송 등, 도메인 클래스는 VO
3) DAO 인터페이스 작성, 실행히야 하는 기능을 인터페이스로 정의 - DAO로 작성하는 것은 향후에 데이터베이스관련 기술이 변경되더라도, DAO만을 변경해서 처리할 수 있도록 하기 위해서
4) XML Mapper의 생성과 SQL문 작성 - Mapper는 SQL 문을 저장하는 존재, Java로 작성된 클래스와 경로를 분리해 주는 것이 유지보수에 있어서 필수적
5) XML 작성 및 SQL 작성 - namespace라는 설정에 가장 신경을 많이 써야함, 클래스의 패키지와 유사한 용도, MyBatis내에서 원하는 SQL 문을 찾아서 실행할 때 동작
6) MyBatis에서 작성된 XML Mapper를 인식하도록 설정 - root-context.xml 설정 변경
7) DAO 구현, DAO 인터페이스를 구현한 클래스 작성 - root-context에서 SqlSessionTemplate의 설정 : 기본적인 트랜잭션의 관리, 쓰레드 처리의 안정성 등을 보장해 주고, 데이터베이스의 연결과 종료를 책임짐
					  - DAO 인터페이스를 구현하는 클래스는 앞에서 설정된 SqlSessionTemplate을 주입받아 사용
					  - @Repository : DAO를 스프링에 인식시키기 위해 사용, @Inject : 의존 주입 (@Autowired도 쓰는데 스프링 전용)
					  - MyBatis의 SqlSession에는 SQL문을 처리할 수 있는 insert, update, delete, seleectOne, selectList등 select 형태를 지원
8) 스프링상에 DAO 등록 및 테스트 - root-context.xml에서 스프링 빈 등록
			     
* log4jdbc-log4j2 설정
- MyBatis의 로그를 보다 자세히 조사할 수 있도록 하는 라이브러리
- pom.xml에 라이브러리 추가 => root-context.xml에서 드라이버 클래스와 연결 URL 변경 => 리소스폴더에 log4jdbc.log4j2.properties, logback.xml 파일 추가

* MyBatis의 #{ } 문법
- XML Mapper를 사용하는 경우 가장 먼저 작업하는 내용은 DAO 인터페이스 => 작성된 인터페이스의 메소드 이름을 기초로 XML Mapper를 작성

* #{ } 기호
- 파라미터가 여러 속성을 가진 객체인 경우 '#{num}'은 getNum() 혹은 setNum()을 의미
- 파라미터가 하나이고, 기본잘형이나 문자열인 경우 값이 그대로 전달
- 파라미터가 Map 타입인 경우 '#{num}'은 Map 객체의 키 값이 'num'인 값을 찾음
