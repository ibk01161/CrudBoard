PART4. AOP와 트랙잭션 처리

#1. Spring의 AOP와 트랜잭션 관리

* AOP란? (Aspect Oriented Programming)
- 비즈니스 로직은 아니지만 반드시 해야하는 작업, 이런 행위를 '횡단 관심사(cross-concern)' 라고 함, 대부분의 개발 과정에는 공통이라고 할 수 있는 무언가가 포함되는 것이 일반적
- '횡단 관심사'의 예로는 보안이나 성능 모니터링 (보안 처리나 로그에 대한 기록, 문제 발생 시를 대비한 이중 백업)
- '횡단 관심사'는 시스템의 여기저기 공통으로 사용되지만 그 자체가 목적은 아님, 오히려 시스템의 완성도를 높여주는 역할을 함

* AOP와 관련된 용어
- 기존 코드를 수정하지 않고 코드의 앞이나 뒤에서 필요한 기능이 동작하도록 작성할 수 있는지의 해답의 실마리는 실제 개발자가 작성한 코드와 컴파일되거나 실행 시 동작하는 코드가 다르다는데 있음
- 이에 대한 구현 방식은 '프록시 패턴'이라는 방식을 통해 구현됨
- 외부에서 특정한 객체(target)를 호출하면, 실제 객체를 감싸고 있는 바깥쪽 객체(proxy)를 통해 호출이 전달됨 => Proxy 객체는 AOP의 기능이 적용된 상태에서 호출 받아 사용되고, 실제 객체와 동일한 타입을 자동으로
  생성할 수 있기 때문에 외부에서는 실제 객체와 동일한 타입으로 호출할 수 있음
1) Aspect - 공통 관심사에 대한 추상적 명칭, 예를 들어 로깅이나 보안, 트랜잭션과 같은 기능 자체에 대한 용어
2) Advice - 실제로 기능을 구현한 객체, 실제 적용시키고 싶은 코드 자체, 개발자가 만드는 것은 Aspect가 아닌 클래스를 제작하고, @Advice를 적용하는 것, 예를 들어 로그 출력 기능, 파라미터 체크 기능 자체는 Aspect라는
               용어로 부르지만, 실제 구현 시에는 Advice를 제작한다고 표현
3) Join points - 공통 관심사를 적용할 수 있는 대상, Spring AOP에서는 각 객체의 메소드가 이에 해당, 작성된 Advice가 활약할 수 있는 위치를 의미, BoardService에서 등록, 수정, 삭제만을 골라 Advice를 적용할 수 있는데,
	       이때 BoardServic의 모든 메소드는 JoinPoint가 됨
4) Pointcuts - 여러 메소드 중 실제 Advice가 적용될 대상 메소드, 여러 Join points 중에서 Advice를 적용할 대상을 선택하는 정보, 이를 통해 특정 메소드는 Advice가 적용된 형태로 동작
5) target - 대상 메소드를 가지는 객체, 실제 비즈니스 로직을 수행하는 객체를 의미, Aspect를 적용해야 하는 대상 객체를 의미
6) Proxy - Advice가 적용되었을 때 만들어지는 객체
7) Introduction - target에는 없는 새로운 메소드나 인스턴스 변수를 추가하는 기능
8) Weaving - Advice와 target이 결합되어서 프록시 객체를 만드는 과정

* Advice의 종류
- Advice는 실제 구현된 클래스로 생각할 수 있는데, Advice의 타입은 여러개로 분류, 어노테이션만을 이용해도 모든 설정 가능
1) Before Advice - target의 메소드 호출 전에 적용
2) After returnig - target의 메소드 호출 이후에 적용
3) After throwing - target의 예외 발생 후 적용
4) After - target의 메소드 호출 후 예외의 발생 관계없이 적용
5) Around - target의 메소드 호출 이전과 이후 모두 적용 (가장 광범위하게 사용), 메소드의 호출 자체를 제어할 수 있음

#2. 샘플 프로젝트의 생성과 AOP의 적용 준비

* 추가해야 하는 라이브러리와 설정
- AOP를 처리하기 위해 Proxy 객체를 생성할 필요가 있음, Proxy 객체를 만드는 방법은 JDK의 InvocationHandler를 이용하는 Dynamic Proxy 방식과 CGLIB를 이용하는 방식이 사용
- AspectJ 언어의 문법을 이용하기 때문에 이와 관련된 라이브러리 추가 (aspectjrt, aspectjweaver)
- root-context.xml에서 사용하는 XML 네임스페이스가 필요하므로 설정 메뉴를 이용해 'aop'와 'tx; 네임스페이스 추가, AOP의 설정을 통한 자동적인 Proxy 객체 생성을 위해 aop:aspectj-autoproxy 설정추가

* 샘플용 테이블 설계
- 사용자 간에 메시지를 남길 수 있는 구조로 샘플용 테이블 설계
- 사용자가 다른 사용자에게 메시지를 남길 수 있다, 메시지를 남긴 사용자는 10포인트 추가, 남겨진 메시지를 읽으면 5포인트 추가

* 샘플용 도메인 객체, DAO, XML, Mapper, 서비스 설계
- 사용자 간에 메시지를 주고받는 내용만 작성
- MessageDAO 인터페이스는 메시지에 대한 등록과 수정 업데이트만 처리하도록 설계, PointDAO는 메시지 전송이나 개봉에 따라 달라지는 사용자의 포인트를 처리하기 위해 설정
- MessageService가 기존 서비스 객체와 다른 점은 두 개의 DAO를 같이 활용해서 하나의 비즈니스 로직을 완성하는 형태로 사용되기 대문에 MessageDAO와 PointDAO를 함께 사용한다는 점
- addMessage()의 메소드를 보면 create()를 호출해 새로운 메시지를 추가하지만, PointDAO를 이용해 메시지를 보낸사람에게 포인트 10점 추가해 주는 작업을 같이 실행
- readMessage()에서는 메시지를 조회하기 때문에 메시지의 상태가 변경돼야하고, 메시지를 본 사람의 포인트가 5점 증가, 모든 작업 후 메시지를 조회해서 반환함
- 서비스 메소드를 실행하기 위해 한번에여러 작업이 동시에 이뤄져야 하는 로직으로 구성돼 있음

#3. AOP 연습하기
- AOP 기능을 활용하기 위해서는 추가로 Advice 객체를 생성하고 이를 어노테이션이나 XML을 이용해 원하는 기능에 적용하는 설정이 필요

* Advice 생성하기
- AOP를 테스트하기 위해 특정한 메소드를 호출할 때 간단한 로그를 기록하는 것과 실행에 걸리는 시간을 로그로 기록하는 것, root-context.xml을 이용해 해당 패키지를 인식할 수 있게 설정
- root-context.xml에 AOP 기능을 설정할 수 있도록 <aop:config>를 추가, 이 설정은 향후 XML 방식으로 AOP 기능을 설정할 때 사용

* SampleAdvice의 작성
- 클래스 선언부의 @Aspect 어노테이션은 AOP 기능을 하는 클래스의 선언에 추가해주는 어노테이션, @Component는 스프링 빈으로 인식되기 위해 설정
- @Before는 해당 메소드를 먼저 실행한 후 target 메소드가 실행되게 하는 것, 'execution'으로 시작하는 구문은 Pointcut을 지정하는 문법으로, AspectJ 언어의 문법을 사용
- MessageService로 시작하는 모든 클래스의 '*'(모든)메소드를 지정하고 있음
- 설정이 올바르게 되면 메소드 앞에 화살표 아이콘이 적용, STS는 AOP의 설정이 적용될 때 개발자가 쉽게 알아볼 수 있도록 아이콘을 통해 알려줌

* 컨트롤러의 작성과 테스트
- 테스트를 위해 MessageController를 작성하고, Advice의 동작을 확인, Ajax 등을 이용해 메시지를 보낼 수 있게 작성

* 실행 시에 전달되는 파라미터 파악하기
- 특정한 컨트롤러를 호출할 때 전달되는 파라미터를 확인해 보는 작업은 빈번하게 일어나므로, SampleAdvice에 새로운 메소드를 추가해 전달되는 모든 파라미터를 확인해야 함
- SampleAdvice의 startLog() 메소드가 전달받는 파라미터가 없기 때문에 org.aspectj.lang.JoinPoint라는 타입을 사용
** JoinPoint의 기능
1) Object[] getArgs() - 전달되는 모든 파라미터들을 Object 배열로 가져옴
2) String getKind() - 해당 Advice의 타입을 알아냄
3) Signature getSignature() - 실행하는 대상 객체의 메소드에 대한 정보를 알아낼 때 사용
4) Object getTarget() - target 객체를 알아낼 때 사용
5) Object geThis() - Advice를 행하는 객체를 알아낼 때 사용

* 가장 강력한 Around
- Advice의 종류에서 가장 강력하게 사용할 수 있는 것은 Around 타입의 Advice
- Around타입은 가른 종류와는 달리 메소드 실행에 직접 관여, 메소드의 실행 전체를 앞, 뒤로 감싸서 특정한 기능을 실행할 수 있는 가장 강력한 타입의 Advice
- Around타입의 기능은 파라미터로 ProceedingJoinPoint 타입을 사용할 수 있는데, Object proceed()라는 메소드가 있음, 기능은 다음 Advice를 실행하거나, 실제 target 객체의 메소드를 실행하는 기능을 함
- ProceedingJoinPoint는 JoinPoint의 하위 인터페이스, JoinPoint의 모든 메소드를 가지면서 직접 target 객체의 메소드를 실행할 수 있는 기능이 추가된 형태
- ProceedingJoinPoint의 proceed()는 특이하게도 Exception 보다 상위의 Throwable을 처리해야 하므로 시간을 체크하는 기능을 작성할 수 있음
- 메소드의 선언에 Exception 대신 Throwable 사용, proceed()를 이용해 실제 메소드를 호출
- @Around를 이용하는 경우 반드시 메소드 리턴 타입은 Object로 선언, 다른 Advice와 달리 @Around는 메소드를 직접 호출하고, 결과를 반환해야만 정상 처리가 됨

#4. Spring의 트랜잭션 처리
- 특별한 경우가 아니라면 데이터베이스의 트랜잭션 처리는 AOP의 설정을 응용, 약간의 설정과 어노테이션만을 이용하면 트랜잭션의 문제가 해결됨, XML을 사용해서 선언하는 방식과 어노테이션을 활용하는 방식으로 나눠짐
- XML을 사용하는 경우에는 별도의 transaction-context.xml 파일을 이용해 XML로 작성해 처리, 어노테이션을 활용하는 경우에는 DAO나 Mapper등을 이용하는 Service클래스에 어노테이션 처리를 통해 해결

* 트랜잭션에 대한 기본 설명
- 트랜잭션은 하나의 업무에 여러 개의 작은 업무들이 같이 묶여 있는 것을 의미, 예로 계좌이체를 들 수 있는데 한 쪽 계좌에서는 출금 다른 쪽 계좌에서는 입금이 행해져 하나의 온전한 프로세스를 구성
- 데이터베이스의 정규화와 트랜잭션은 서로 관련이 있는 경우가 많음
- 정규화가 잘 돼 있을수록 관련을 맺는 데이터는 줄어듬, 성능의 이유나 구현상의 복잡함으로 인해 반정규화가 많이 진행되는 경우에는 트랜잭션을 처리해야 하는 상황이 많아짐
** 시스템에서 가장 흔하게 처리되는 트랜잭션 상황
1) 회원이 특정 게시판에 게시글을 추가하면 회원의 포인트가 올라가야 하는 상황
2) 원글에 댓글이 추가되면 댓글 테이블에 게시물이 등록되고, 원글에는 댓글의 숫자가 업데이트 돼야 하는 상황
3) 문의 게시판에 글을 등록하면 데이터베이스에도 글이 등록되지만, 담당자에게도 메일이 발송 돼야 하는 상황
=> 하나의 업무가 단순한 CRUD로 구성되는 것이 아닌, 두 개 이상의 잡업이 묶여 있음

* 트랜잭션을 처리하는 상황 이해하기 (예제에 대한 상황)
1) 사용자가 다른 사용자에게 메시지를 남길 때 - 메시지 등록, 10포인트 증가
2) 남겨진 메시지를 읽는 작업 - 메시지 상태가 읽은 상태로 변경, 메시지를 읽는 사용자의 포인트가 5점 증가, 메시지 조회 기능

* @Transactional 어노테이션
- 스프링에서 트랜잭션을 처리하기 위해 제공되는 어노테이션
- 전파 속성, 격리 레벨, Read-only 속성, Rollback-for-예외, No-rollback-for-예외 라는 속성이 있음

* 트랜잭션 매니저의 설정
- 트랜잭션을 처리하기 위해 트랜잭션 매니저를 설정해 줘야 함
- root-context.xml에서 DataSource의 설정이 존재하는 곳에 적용
- 하나의 DataSource를 사용하는 경우에는 스프링에서 제공하는 DataSourceTransactionManager를 이용, 이때 필요한 DataSource를 주입받도록 함, 어노테이션 사용을 위해 <tx:annotation-driven /> 설정

* 트랜잭션 적용 테스트
- @Transactional 어노테이션은 인터페이스와 클래스, 메소드 선언에서 사용할 수 있는데 적용은 반대로 우선순위가 높음
- 메소드에 선언한 어노테이션 설정이 가장 우선되기 때문에, 일반적인 경우라면 클래스나 인터페이스에는 공통적인 규칙을 선언하고, 메소드에는 특별한 설정을 추가하는 경우가 많음

* Service의 트랜잭션 처리 후 테스트
- MessageServiceImpl을 수정해 @Transactional 어노테이션 추가, 소스코드에 트랜잭션 처리가 되어 Around 형태로 아이콘이 나타남

* @Transactional의 적용 순서
- 메소드에 설정하는 것도 가능하지만, 클래스나 인터페이스에 선언하는 것 역시 가능
- 우선순위는 메소드 > 클래스 > 인터페이스로 메소드 설정이 가장 우선이고 인터페이스 설정이 가장 낮은 우선순위임
- 인터페이스에는 가장 기준이 되는 @Transactional 설정을 하고, 클래스나 메소드에 필요한 어노테이션을 처리하는 것이 좋음

#5. 게시물의 댓글에 따른 트랜잭션 처리
- 게시물에서 댓글이 추가될 때 댓글의 숫자를 업데이트 시키는 기능, 댓글의 숫자를 업데이트하는 기능이 존재하기 때문에 트랜잭션 처리 예제로 적합
- 게시물 테이블에 댓글의 수 컬럼을 추가하고, 댓글 등록 시 증가하도록 처리 + 댓글 삭제 시 댓글의 숫자를 줄이는 기능 추가

* 댓글 카운트의 처리
1) 게시물 테이블에 댓글 수 컬럼 추가 - 댓글을 추가하는 경우 댓글의 수를 증가시켜야 하고, 댓글을 삭제하는 경우는 감소시켜야 하므로 이를 위한 메소드를 설계
2) BoardVO 변경 - 새로운 replycnt 속성 추가
3) boardMapper.xml의 SQL 문 변경 - xml에서 replycnt 칼럼이 필요한 부분을 찾아 수정
4) BoardDAO, ReplyDAO 변경 
- 댓글은 게시물과 같이 연동하여 처리되기 때문에 BoardDAO, ReplyDAO에 댓글 관련 기능을 활용할 수 있게 변경
- BoardDAO에 댓글의 숫자를 변경할 수 있는 메소드 추가, ReplyDAO에는 댓글이 삭제될 때 해당 게시물 번호를 알아내는 기능을 추가
5) ReplyServiceImpl의 수정
 - 댓글의 등록과 삭제 시 처리할 부분이 있기 때문에 ReplyDAO와 BoardDAO를 같이 사용하도록 수정
- 댓글이 추가되면 replycnt 값을 1 증가시키도록 addReply 메소드 수정, 삭제시 replycnt 값을 1 감소하도록 removeReply 메소드 수정 (@Transactional 이용)
6) 조회 화면의 댓글 수 출력
- 댓글에 대한 처리가 완료되면 댓글의 숫자를 조회하는 방식에도 차이가 생김
- 과거에는 해당 게시물의 모든 댓글 숫자를 'select count(rno) from tbl_reply wehre bno = #{bno}' 형태로 사용했지만 트랜잭션으로 댓글의 숫자가 처리되는 상황에서는 tbl_board만을 이용해서 처리 가능
- 목록에서 댓글의 숫자를 미리 보여주는 기능이 있는 list,jsp 파일 수정
- 글 조회 화면에서 '댓글 보기' 버튼을 클릭해야만 댓글을 확인할 수 있었는데 readPage.jsp를 수정해 댓글의 수를 볼 수 있도록 처리
- 댓글의 숫자를 보여주는 작업은 tbl_board를 통해 이뤄지지만, 댓글의 삭제는 Ajax를 통해 tbl_reply를 이용, 댓글 페이징 처리 시 댓글의 숫자를 이용해 위의 숫자를 갱신해 줘야 함
- Ajax를 통해 가져오는 데이터인 pageMaker는 내부에 totalCount 데이터를 가지고 있기 때문에 이를 이용해 화면을 처리할 수 있음

* 조회 숫자 처리
- 게시물의 조회 숫자 처리는 게시물의 내용을 가져오기 전 update를 먼저 진행하고 이후 select를 통해 게시물을 가져오게 처리
1) DAO, XML Mapper, DAOImpl 수정
2) Service 수정 - ServiceImpl에서는 트랜잭션의 격리 수준 활용, 격리 수준은 대부분의 데이터베이스가 기본으로 사용하는 수준으로, 다른 연결이 커밋하지 않은 데이터는 볼 수 없도록 함(Isolation.READ_COMMITTED)

* 정리
- 스프링은 핵심적인 비즈니스 로직과 그렇지 않은 로직을 분리하는 기법으로 AOP를 사용
- 스프링의 AOP는 선언적인 형태로 처리되어 약간의 설정만으로 사용가능
- Advice의 종류 중에는 Around를 이용하는 것이 가장 강력
- 스프링은 트랜잭션 역시 AOP의 설정과 유사하게 적용할 수 있음





































