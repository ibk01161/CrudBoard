PART6. 인터셉터를 활용하는 로그인 처리

#1. Spring MVC의 인터셉터(Interceptor)
- 스프링을 이용해 로그인을 처리하는 가장 간단한 방법은 Servlet의 Filter와 유사한 인터셉터를 활용하는 방법
- 스프링 MVC에서 인터셉터는 웹 어플리케이션 내에 특정한 URI 호출을 말 그대로 '가로채는' 역할을 함
- 이를 활용하면 로그인한 사용자만 사용할 수 있는 기능을 제어할 수 있기 때문에 기존 컨트롤러의 로직을 수정하지 않고도, 사전이나 사후에 제어가 가능

* Filter와 인터셉터의 공통점과 차이점
- 공통점 : 특정 URI에 접근할 때 제어하는 용도로 사용, web.xml 설정 유사
- 차이점 : 시점에 속하는 영역(Context)이 가장 큰 차이
- F : 동일한 웹 어플리케이션의 영역 내에서 필요한 자원들을 활용 (스프링의 Context를 접근하기 어렵)
- I : 스프링에서 관리되기 때문에 스프링 내의 모든 객체(빈)에 접근이 가능 (스프링의 Context내에 존재하므로 Context내의 모든 객체 활용 가능), 기존 구조를 그대로 활용하면서 추가적 작업 가능

* Spring AOP 기능과 HandlerInterceptor의 차이
- 특정 객체 동작의 사전 혹은 사후 처리는 AOP 기능을 통해 확인했지만, 일반적인 경우라면 컨트롤러를 이용할 때는 
AOP의 BeforeAdvice등을 활용하기보다 HandlerInterceptor 인터페이스 혹은 HandlerInterceptorAdaptor 클래스를 활용하는 경우가 더 많음

* AOP의 Advice와 HandlerInterceptor의 차이점 - 파라미터의 차이
A : JoinPoint나 ProceedingJoinPoint등을 활용해 호출 대상이 되는 메소드의 파라미터 등을 처리하는 방식
H : Filter와 유사하게 HttpServletRequest, HttpServletResponse를 파라미터로 받는 구조
     기존의 컨트롤러에서는 순수하게 필요한 파라미터와 결과 데이터를 만들어 내고, 인터셉터를 이용해 웹과 관련된 처리를 도와주는 역할을 함

* HandlerInterceptor에 존재하는 메소드
- preHandle(request, response, handler) : 지정된 컨트롤러의동작 이전에 가로채는 역할로 사용
- postHandle(request, response, handler, modelAnView) : 지정된 컨트롤러의 동작 이후에 처리, Spring MVC의 Front Controller인 DispatcherServlet이 화면을 처리하기 전에 동작
- afterCompletion(request, response, handler, modelAnView) : DispatcherServlet의 화면 처리가 완료된 상태에서 처리
=> 대부분은 preHandle()을 이용해 로그인에 대한 처리를 진행하는 것이 일반적

* HandlerInterceptorAdapter 클래스
- 인터페이스를 구현한 추상 클래스로 설계되어 있음
- 일반적으로 디자인 패턴에서 adapter라는 용어가 붙으면 특정 인터페이스를 미리 구현해서 사용하기 쉽게 하는 용도인 경우가 많음
- HandlerInterceptor를 쉽게 사용하기 위해 인터페이스의 메소드를 미리 구현한 클래스

* 예제 프로젝트 생성
1) 패키지의 생성과 SampleInterceptor - HandlerInterceptorAdaptor를 상속해서 사용하는 클래스들을 보관하는 패키지를 작성
2) servlet-context.xml의 인터셉터 설정 - 작성된 SampleInterceptor를 스프링에서 인식하려면 servlet-context.xml에 설정이 추가돼야 함
			          - 다른 객체들의 설정과 달리 인터셉터의 경우 URI 설정이 추가되므로 설정 방식 자체가 다름
			          - <interceptors> 태그를 이용해서 설정, 이 태그를 이용하기 위해 XML 네임스페이스에 spring mvc 관련 설정이 추가돼 있어야만 함
			          - 각 인터셉터의 <mapping>에는 원하는 URI를 지정, 이러한 설정은 web.xml의 필터나 Servlet의 설정과 동일, 필요한 경로를 직접 지정하거나 '**','*' 패턴 적용 가능
3) HomeController의 수정 - 테스트를 위해 간단한 메소드를 작성하고, @RequestMapping을 '/doA', '/doB'로 작성
4) SampleInterceptor의 처리 - preHandle()과 postHandle()을 이용해 간단하게 출력하는 코드 작성
		          - preHandle()의 경우 리턴 타입이 boolean으로 설계됨, 이를 이용해 다음 Interceptor나 대상 컨트롤러를 호출하도록 할 것인지를 결정
5) 결과 확인 - WAS상에서 '/' 경로로 동작하도록 설정한 후 '/doA, /doB'를 브라우저에서 호출하여 실행되는 결과를 확인
	   - 로그를 보면 preHandle()이 가장 먼저 호출되고, 메소드가 동작한 후 postHandle()이 동작하는 것을 볼 수 있음

* 인터셉터의 request, response 활용하기
- 인터셉터를 좀 더 적극적으로 활용하면 컨트롤러가 웹에서 필요한 자원을 처리할 때 겪는 불편을 해소하는데 도움이 됨
1) preHandle()의 Object 파라미터 : 세 개의 파라미터를 사용하는데 HttpServletRequest, HttpServletResponse, Object handler로 구성
			    마지막의 Handler는 현재 실행하려는 메소드 자체를 의미하는데 이를 활용하면 현재 실행되는 컨트롤러를 파악하거나, 추가적인 메소드를 실행하는 등 작업이 가능
2) postHandle()을 이용해 추가적인 작업하기
- postHandle의 경우 컨트롤러 메소드의 실행이 끝나고 아직 화면처리는 안 된 상태이므로, 필요하다면 메소드의 실행 이후 추가적인 작업이 가능
- 예를 들어 특정 메소드의 실행 결과를 HttpSession객체에 같이 담아야 하는 경우를 생각해 볼 때 컨트롤러에서는 Model 객체에 결과 데이터를 저장하고, 인터셉터의 postHandle에서 이를 이용해 HttpSession에 결과를 담는다면
  컨트롤러에서 HttpSession을 처리할 필요가 없게 됨 (예제_컨트로러에서 'result'라는 변수가 저장되었다면 HttpSession 객체에 이를 보관하는 예)
- 컨트롤러의 코드에서 '/doB'를 호출하면, 'result'라는 이름으로 하나의 문자열이 보관됨, 그 이후 postHandle()에서 'result'라는 변수가 ModelAndView에 존재하면 이를 추출해 HttpSession에 추가함
- 예제 코드는 HomeController의 '/doB'를 먼저 호출해서 HttpSession에 'result'라는 이름을 보관한 후 '/doA'로 redirect를 수행하게 됨, /doA가 보여주는 jsp 화면 작성해야 함
- 브라우저에서 '/doB'를 호출하게 되면 '/doA'로 이동하는데, HttpSession에 'result'이름으로 보관된 객체가 있으므로, 화면에는 'result'에 해당하는 문자열이 보여지게 됨
  (doB를 실행했을 때 HttpSession에 필요한 데이터를 담고, doA의 URI를 호출한 결과 => jsp에서는 Model 객체에서 전달된 객체는 없지만, HttpSession 개체에 필요한 정보가 보관되었기에 EL의 문법을 이용해 문자열 출력됨)
- 위 예제는 로그인 처리에서 유용하게 사용할 수 있음
  컨트롤러에서는 로그인 처리 후 결과를 반환하고, 인터셉터를 이용해 HttpSession에 로그인이 필요한 객체를 보관하는 형태로 작성하면 컨트롤러에서 직적 HttpSession 등의 API를 사용하지 않는 코드를 만들 수 있음


#2. HttpSession을 이용하는 로그인 처리
- 웹에서 로그인의 가장 기본적인 방식은 HttpSession 객체를 이용해 사용자의 정보를 보관하고, 필요한 경우 사용하거나 수정하는 방식
- HttpSession의 동작은 실제로 세션 쿠키(session cookie)를 통해 이뤄지는데, 서버는 필요한 경우 접속한 브라우저에게 고유한 세션 쿠키를 전달하고
  매번 브라우저에서 서버를 호출할 때 세션 쿠키를 같이 가지고 다니기 때문에, 이를 마치 열쇠처러 사용해 필요한 데이터를 보관함
- 세션 쿠키가 열쇠라면 HttpSession은 열쇠가 필요한 잠금장치가 되어있는 상자와 유사함
- 이 상자들이 모여있는 공간을 '세션 저장소(Session Repository)'라고 하는데, 너무나 많은 세션이 존재하면 서버의 성능에 영향을 미치기 때문에, 서버에는 일정 시간 이상 사용되지 않는 상자들을 정리하는 기능이 있음
  (web.xml을 이용해 HttpSession의 timeout을 지정할 수 있음)
- 세션을 이용하는 방식의 핵심은 HttpSession을 이용해서 원하는 객체를 보관할 수 있다는 점
- 사용자는 항상 열쇠에 해당하는 세션 쿠키를 가지고 접근하고, 서버의 내부에 상자가 필요한 객체를 보관하기 때문에 안전하다는 장점이 있음
- 세션에 보관된 객체는 JSP에서 EL을 이용해 자동으로 추적하는 방식을 사용
- 예를 들어 ${name}은 page=> request=> session=> application의 순서대로 원하는 데이터를 검색함
- 이와 같은 방식으로 동작하기 때문에 JSP를 개발하는 개발자는 자신이 사용하는 변수가 request에 존재하는 것인지, 세션에 존재하는 것인지에 대해 고민하지 않아도 됨

* HttpSession을 이용하는 로그인 처리 순서
- 로그인을 하는 경우 사용자의 정보는 DTO(Data Transfer Object) 혹은 VO(value Object)를 이용해 보관되고, 세션에 보관하게 됨
1) 테이블 생성 및 객체 처리 - 로그인을 처리하기 위해 유저 테이블 작성, 세션에 보관될 UserVO 클래스 설계, 화면에서 전달하는 데이터를 수집하는 용도로 LoginDTO라는 클래스 작성
** VO와 DTO
- 일반적으로 컨트롤러에 전달되는 데이터를 수집하는 용도로 VO를 사용하는 경우도 있고, DTO를 사용하는 경우가 있음
- DTO와 VO의 용도는 데이터의 수집과 전달에 사용할 수 있다는 공통점이 있음
- 양쪽 모두 파라미터나 리턴 타입으로 사용하는 것이 가능
- VO의 경우 보다 데이터베이스와의 거리가 가까움, VO는 테이블의 구조를 이용해서 작성되는 경우가 더 많음
- DTO의 경우는 보다 화면과 가까움, 화면에서 전달되는 데이터를 수집하는 용도로 사용하는 경우가 많음
- 스프링 MVC를 이용하는 경우 DTO는 검증을 위한 처리가 들어감, 스프링은 Controller에 전달되는 데이터에 대해서 검증하는 기능을 추가할 수 있는데 이러한 상황에서는 별도의 DTO를 구성해서 사용
2) UserDAO의 생성 및 SQL 처리
- 로그인할 때 사용자의 아이디와 패스워드를 이용해 사용자의 정보를 조회하는 SQL문을 처리
3) UserService와 UserServiceImpl 처리
4) 컨트롤러의 처리 - 컨트롤러에서 HttpSession 객체를 처리할지, 인터셉터에서 HttpSession을 처리할 것인지 결정 해야함 (예제에서는 인터셉터에서 처리)
	            - 스프링 MVC 컨트롤러에서 필요한 모든 자원을 파라미터에서 수집해 처리하기 때문에 HttpServletRequest나 HttpSession과 같은 자원들 역시 파라미터로 처리해도 문제X
	            - 스프링의 인터셉터는 웹 관련 API를 처리하는 용도로 사용되기 때문에 가능하면 컨트롤러 역시 기존 방식과 동일하게 제작하는 것이 좋음
	            - 만들어진 컨트롤러의 경우 기존 컨트롤러들과 전혀 차이가 없이 POST방식으로 파라미터를 이용해 Model에 UserVO 객체를 추가
	            - 기본경로를 '/user'이고, 로그인 화면은 '/user/login', 결과처리는 '/user/loginPOST'로 설정
	            - 실제 로그인 처리가 이뤄지는 loginPost()에서는 Model 객체에 사용자가 존재하는 경우에 'userVO'라는 이름으로 저장하게 됨
5) 로그인인터셉터의 작성 및 설정 - 컨트롤러에서 HttpSession과 관련된 아무런 작업도 처리된 적이 없기 때문에 HttpSession에 관련된 모든 설정은 인터셉터에서 처리
			    - LoginInterceptor는 '/loginPost'로 접근하도록 설정하는 것을 목적으로 작성
			    - preHandle()에서는 기존 HttpSession에 남아있는 정보가 있는 경우에 정보를 삭제
			    - postHandle()에서는 UserController에서 'userVO'라는 이름으로 객체를 담아둔 상태이므로, 이 상태를 체크해 HttpSession에 저장

6) LoginInterceptor의 설정 - LoginInterceptor의 설정은 '/loginPost'의 동작에서 이뤄져야 하므로 servelet-context.xml의 설정 필요
		        - 인터셉터의 설정을 보면 '/user/loginPost' 경로를 호출하도록 설정, 인터셉터 설정에는 프로젝트의 경로는 포함되지 않음
7) 로그인 화면 처리 - form에 action 속성의 값은 '/user/loginPost'를 호출, 결과 페이지에 해당하는 loginPost.jsp는 아직 아무런 처리가 없기 때문에 게시물 목록으로 이동
8) AuthInterceptor의 작성 - LoginInterceptor가 로그인한 사용자에 대해 postHandle()을 이용해 HttpSession에 보관하는 처리를 담당한다면 AuthInterceptor는 특정 경로에 접근하는 경우 현재 사용자가 로그인한 상태의 사용자
		          인지 체크하는 역할을 처리하기 위해 작성
		       - AuthInterceptor는 perHandle()을 이용해 현재 사용자가 로그인한 상태인지를 체크하고, 컨트롤러를 호출하게 할 것인지 결정, 사용자가 로그인하지 않은 상태라면 로그인화면으로 이동
9) AuthInterceptor의 설정 - 많은곳에서 사용하겠지만 '게시물의 입력 화면'에서 처리 (servlet-context.xml에서 설정)
		       - 설정 후 실행시키면 로그인하지 않은 사용자가 게시물 작성에 접근하게 되면 사용자는 로그인 화면을 보게 됨
10) 자동 페이지의 이동 처리 - AuthInterceptor에서 사용자가 원하는 URI가 무엇인지를 보관했다가, 로그인 성공 후 해당 경로로 이동시켜줘야 함
		          - 위 화면의 겨우 사용자는 게시물 작성 페이지 => 로그인 페이지로 이동한 케이스이므로 Interceptor에서는 원래 가려고 했던 URI를 저장했다가 로그인 후 이동시키는 작업 필요
		          - saveDest() 메소드를 이용해 원래 사용자가 원하는 페이지의 정보를 HttpSession에 'dest'라는 이름으로 저장, GET방식인 경우 URI 정보 뒤 파라미터들을 함께 보관
		          - LoginInterceptor는 로그인 성공 후 sendRedirect()에 'dest' 정보를 사용하도록 수정

#3. 게시물의 세부 기능 적용
- 로그인 처리와 관련해서 인터셉터나 컨트롤러의 처리가 중요하지만, JSP와 같은 화면에서의 처리가 많은 시간이 소비가 됨
- 로그인 세부 처리는 크게 인터셉터가 적용된 URI를 결정하는 작업과, JSP내에서 코드 수정 작업으로 나누어짐
- 이 장에서 게시물 등록과 수정, 삭제에는 로그인 여부를 체크하는 기능이 추가됨
1) 인터셉터 URI Mapping
* 로그인한 사용자
- 게시물 등록, 게시물 수정/삭제, 댓글 추가/수정/삭제
* 일반 사용자
- 게시물 목록, 게시물 조회, 댓글 목록
2) servlet-context.xml 설정
- 게시물 등록/수정/삭제에 대한 인터셉터 적용
3) 각 JSP 별 로그인 처리 (등록, 조회, 조회 댓글 추가, 댓글 수정/삭제 페이지)
* 게시물 등록 페이지
- jsp에서 사용하는 EL의 경우 자동으로 HttpSession에 있는 'login'을 찾아 사용하므로 '${login.uid}'와 같은 형태로 사용할 수 있음
* 게시물 조회 페이지
- 게시물 수정 자체가 로그인한 사용자만이 가능하기 때문에 수정 버튼을 제한, 게시물을 작성한 사용자만이 수정할 수 있도록 해야 함
* 조회 페이지 내에서의 댓글 추가
- 조회 페이지의 경우 댓글과 관련된 작업이 이루어짐, 사용자의 로그인에 따라 영향을 받는 부분 수정
- 댓글 추가 : 로그인한 사용자의 경우 댓글 작성자는 로그인한 사용자의 아이디로 구성돼야함
- 댓글 수정/삭제 : 댓글 목록을 보는 것은 자유지만, 자신이 작성한 댓글만 수정/삭제가 가능하게 구성돼야함
- JSTL로 화면에 로그인한 사용자와 그렇지 않은 사용자의 아이디를 구분 (로그인 객체가 있으면 writer의 id 이름 value로 집어넣고, 댓글 추가 버튼 보이기/ 없으면 로그인 페이지로 가는 안내버튼 보이기)
* 댓글 수정/삭제 작성자 확인
- 댓글 목록은 로그인 관계없이 볼 수 있지만, 수정/삭제 작업은 로그인한 사용자가 작성한 본인 댓글만이 수정이 가능하도록 처리해야함
- 댓글 목록이 처리되는 방식은 Ajax와 handlerbars를 이용했기 때문에 handlerbars의 기능을 좀 더 확장해서 댓글 수정화면으로 진입할 수 있는 버튼이 보여지는 것을 제어해야함
- handlerbars의 기능을 확장하기 위해 'eqReplyer'를 작성했고, ${login.uid} 를 활용해 로그인 사용자의 경우 값을 비교하도록 작성

#4. 자동 로그인과 쿠키
- 자동 로그인은 브라우저가 서버에 접속할 때 특정한 쿠키를 같이 전송하고, 이를 이용해서 로그인을 처리하는 방식입니다.
- HttpSession에서 사용되는 세션 쿠키와 달리 개발자가 만들어 내는 쿠키의 경우 '만료기한'을 지정할 수 있기 때문에 오랜 기간 보관 가능
- 일반적으로 웹 로그인은 세션을 사용하는 방식을 더 선호, 이유는 보안에 대한 문제 때문, 세션을 이용하는 경우 로그인한 사용자의 정보는 서버의 내부에서만 사용되기 때문에 보안상 유리
- 반면에 쿠키는 매번 브라우저와 서버 사이에서 주고받는 방식으로 동작하기 때문에 쿠키에 특정값이 기록된 경우 보안에 취약함, 세션과 달리 쿠키에는 길이제한, 문자열만 보관할 수 있는 문제 존재
- 쿠키가 자동 로그인으로 적극적으로 활용된 계기는 모바일에서 매번 로그인하기가 힘들다는 문제에 대한 대안으로 사용되면서 부터임

* 쿠키를 이용하는 자동 로그인 방식
- 자동로그인을 처리하기 전 우선 사용자가 로그인한 후 쿠키를 만들어 브라우저로 전송하고, 다시 서버에 접속할 때 쿠키가 전달되는지 확인해야함

* LoginInterceptor에서의 쿠키 생성
- 앞서 postHandle()을 이용해 HttpSession에 UserVO 타입의 객체를 보관했지만, 이를 수정해 중간에 쿠키를 생성하고, HttpServletResponse에 같이 담아 전송하도록 수정
- 사용자가 '자동 로그인'을 선택한 경우 쿠키를 생성하고 생성된 쿠키의 이름은 loginCookie로 지정
- 생성된 loginCookie에는 값으로 현재 세션 아이디 값을 보관 (세션 아이디는 세션 쿠키의 값을 의미)
- 세션 쿠키의 경우 브라우저 종료시 사라지지만, loginCookie의 경우 오랜 시간 보관되기 위해 setMaxAge()를 이용 
- setMaxAge()는 초 단위의 시간동안 유효하므로 60*60*24*7를 이용해 일주일간 브라우저에서 보관됨
- 만들어진 쿠키는 반드시 HttpServletResponse에 담겨서 전송됨
- 수정된 소스를 이용해 로그인한 후 여러 페이지에서 매번 브라우저에 'loginCookie'가 전달되는 것을 개발자 도구를 이용해 확인
- 개발자 도구를 활용해서 쿠키 정보를 확인해보면 'JSESSIONID'는 톰캣에서 발행된 세션 쿠키 이름이고, 'loginCookie'는 인터셉터에 의해 만들어진 쿠키임 (현재 쿠키값과 동일한 값이 loginCookie에 기록됨)
- 브라우저 종료 후 5분이내로 접속하면 세션 쿠키가 없는 상황이므로, 'JSESSIONID' 와 같은 세션 쿠키는 존재하지 않지만, 일주일간 유효기간이 지정된 쿠키는 그 값을 유지하고 있음
- 세션 쿠키는 브라우저가 종료될 때 같이 종료되었기 때문에 브라우저를 새로 실행할때마다 새롭게 만들어짐, 반면 loginCookie의 경우 로그인할 때 브라우저를 이용해 보관됨

* 자동 로그인 구상
- 자동 로그인 처리의 기본 아이디어는 '세션 + 쿠키' 를 이용
- 보통 HttpSession만을 이용하거나 쿠키만 이용하지만, 두 가지를 섞어서 사용 (이전 코드에 대한 이해)
** 쿠키와 세션으로 발생하는 상황
1) HttpSession에 'login' 이름으로 보관된 객체가 없고, 'loginCookie'가 없는 경우
=> 로그인과 관련된 아무런 정보가 없으므로, 사용자는 로그인이 필요한 상황
2) HttpSession에 'login'이름으로 보관된 객체가 있고, 'loginCookie'가 없는 경우
=> 세션에 login이라는 이름으로 보관된 경우는 현재 사용자가 로그인한 상황
3) HttpSession에 'login'이름으로 보관된 객체가 없고, 'loginCookie'가 있는 경우
=> 사용자는 이전에 로그인을 한 적이 있을 수 있음, 이전에 로그인 할 때 loginCookie가 생성되었을 것이고, 브라우저를 종료했을 것
=> 브라우저가 종료되면서, 세션 쿠키는 사라졌지만, loginCookie는 7일 동안 보관되므로, 7일 사이에 접속한 적이 있음
4) HttpSession에 'login'이름으로 보관된 객체가 있고, 'loginCookie'가 있는 경우
=> 현재 접속 중인 사용자
- 위 경우 중 자동 로그인은 3번, 이 경우는 이전에 로그인을 한적이 있다는 것을 의미, 과거 로그인 시점에 기록된 정보를 이용해 다시 HttpSession에 login이란 이름으로 UserVO 객체를 보관해줘야 함
- 이후의 모든 작업은 HttpSession에 login 이름으로 저장된 객체가 있으므로, 모두 해결

* 자동 로그인 구현
- 사용자가 loginCookie를 가지고 있으면 그 값은 과거에 로그인한 시점에 세션 아이디이다.
- 이를 반대로 해석하면 loginCookie에 있는 값을 이용해 데이터베이스에서 UserVO의 정보를 읽어오고, 읽어온 UserVO 객체를 현재 HttpSession에 보관하면 로그인이 돼야함

** 간단한 순서
1) 사용자가 로그인하면 데이터베이스에 현재 세션의 ID값과 유효기간(7일)을 기록
2) 사용자가 로그인하지 않은 상황에서 쿠키를 가지고 접속하면 쿠키의 내용물을 추출
3) 쿠키의 내용물로 데이터베이스를 조회해서 유효기간에 맞는 값인지 확인
4) 확인된 사용자는 세션에 로그인한 정보를 기록해서, 자동으로 로그인이 되도록 함

*** 소스 수정
1) 데이터베이스의 변경 (tbl_user테이블 변경)
- 로그인하는 시점의 세션 아이디를 보관하는 'sessionkey' 컬럼과 유효시간을 기록하는 'sessionlimit' 컬럼 추가-
- sessionlimit컬럼의 경우 서버에서 다시 한 번 유효한 기간에 다시 접속을 했는지를 판단하기 위해 작성
* 사용자가 로그인을 하면 위의 컬럼들이 업데이트 돼야 하므로, 해당 SQL을 작성해야하기 위해 소스 수정 필요
2) UserDAO 변경, Mapper xml 쿼리 추가, UserDAOImpl 수정
- UserDAO에는 로그인한 사용자의 sessionKey와 sessionLimit를 업데이트하는 기능(keepLogin)과 loginCookie에 기록된 값으로 사용자의 정보를 조회하는 기능(checkUserWithSessionKey) 추가 
3) UserService 및 UserServiceImpl의 변경
- UserService에서는 로그인 정보를 유지하는 keepLogin과 과거에 접속한 사용자인지를 확인하는 기능을 작성
4) UserController의 변경
- '자동로그인'을 선택한 경우 필요한 기능 추가
- loginCookie 값이 유지되는 시간 정보를 데이터베이스에 저장
5) AuthInterceptor의 변경
- 인터셉터에서는 현재 사용자의 세션에 login이 존재하지 않지만, 쿠키 중에서 loginCookie가 존재할 때 처리가 진행
- UserService 타입의 객체를 주입
- 현재 사용자가 HttpSession에 적당한 값이 없는경우 loginCookie를 가지고 있는지 체크
- 만약 과거에 보관한 쿠키가 있다면 UserService 객체를 이용해 사용자의 정보가 존재하는지 확인
- 만약 사용자 정보가 존재한다면 HttpSession에 다시 사용자의 정보를 넣어주면 됨

* 자동 로그인 테스트
- 로그인하지 않은 사용자가 로그인이 필요한 URI에 접근하는 경우 : 로그인 페이지로 이동
- 로그인할 때 자동로그인을 체크하지 않은 상태에서 로그인 실행, 이후 로그인이 필요한 페이지로 이동 : 정상적인 이동
- 브라우저 종료 후 2번 테스트 다시 진행 : HttpSession이 변경됐으므로, 로그인 페이지로 이동
- 로그인 화면에서 자동로그인 체크하고 로그인
- 브라우저 종료하고 다시 샐행한 후 로그인이 필요한 URI 접속 : 정상적인 이동

- 현재 코드의 설정은 쿠키가 7일동안 로그인이 유지되도록 설정됐으므로, WAS를 재시작해도 아무런 문제 없이 작동됨

* 로그아웃 처리
- 로그아웃은 HttpSession의 경우 login과 같이 저장된 정보를 삭제하고, invalidate()를 주는 작업과 쿠키의 유효시간을 변경하는 작업으로 이루어짐
- 자동로그인에 데이터베이스를 이용했다면 데이터베이스의 갱신도 함께 이뤄져야 함
- UserController에서 로그아웃 처리를 위해직접 파라미터로 HttpServletRequest 등을 받는 방식이 가장 단순하고, 별도 인터셉터를 이용하는 방식도 사용해볼만 함
- logout.jsp는 별다른 내용 없이 '/crud'와 같은 경로로 이동하는 코드만 작성하면 됨













