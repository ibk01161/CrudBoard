PART2. 기본적인 기능의 게시물 관리

#1. 등록, 수정, 삭제, 조회 기능의 구현

* 프로젝트 생성
1) Spring Legacy Project 생성
2) pom.xml 수정
3) DataSource 등록 (데이터베이스 관련), UTF-8 처리 필터 등록 (한글처리)
4) 개발 패키지 구성 (DAO, controller, XML 등등)
5) 테이블 생성 (Data Source Exporer에 해당 계정 연결, ERMaster로 ERD만들기)

#2. 영속(persistence) 계층, 비즈니스 계층

1) 테이블의 구조를 객체화시킴 (BoardVO클래스 작성)
2) DAO 생성과 XML Mapper 작업 (XML 네임스페이스 추가 => SessionFactory, SqlSessionTemplate 추가 => BoardDAO 생성 => XML 파일 생성)
* xml의 각 SQL 문의 id 속성 값은 BoardDAO 인터페이스와 동일하게 설정
* XML Mapper를 이용하는데 있어 매번 parameterType이나 ressultType에 패키지 까지 포함된 클래스명을 작성하는 일이 번거로우면 mybatis-config.xml을 사용해 <typeAliases> 적용 => 클래스이름 생략 가능
3) BoardDAO의 구현 클래스 BoardDAOImpl 작성
4) JUnit을 사용해 BoardDAO 테스트
5) 비즈니스 계층 : 고객의 요구사항이 반영되는 영역, 비즈니스 영역에 만들어지는 클래스나 인터페이스는 반드시 요구사항과 일치하도록 설계 
(요구사항을 메소드로 정리해서 ~Service 인터페이스 정의 => ~ServiceImpl이라는 구현 객체를 만듦, 클래스 선언부에는 스프링의 빈으로 인식되기 위해 @Service 어노테이션 적용)
* 비즈니스 계층
- 컨트롤러와 DAO 사이의 접착제 역할
- 고객마다 다른 부분을 처리할 수 있는 완충장치 역할
- 회사마다 다른 로직이나 규칙을 데이터베이스에 무관하게 처리할 수 있는 완충 영역으로 존재
- 컨트롤러와 같은 외부 호출이 영속 계층에 종속적인 상황을 막아줌
- 컨트롤러로 하여금 처리해야 하는 일을 분업하게 만들어 줌

* 비즈니스 계층의 구현
- 로직에 필요한 데이터베이스 관련 객체들을 모아 자신의 원하는 일을 처리하는 용도

#3. 등록 구현 - 컨트롤러와 프레젠테이션 계층

* 컨트롤러 관련 고민들
- 공통적인 URI 경로와 각 기능별 URI
- 각 URI에 대한 호출 방식(GET, POST)
- 결과 처리와 리다이렉트 방식의 페이지 결정
- 예외 페이지

* 공통 경로의 처리와 호출 방식
- 컨트롤러 설계는 특별한 경우가 아니면 모듈(메뉴나 기능의 묶음)의 개수에 맞게 컨트롤러의 숫자를 제 (회원, 게시판 모듈이 필요하면 하나씩 컨트롤러 제작)
- 하나의 모듈을 나타내는 대표적인 경로를 갖도록 해 주는 것이 좋음 (게시판일 경우 '/board/ 혹은 /boards/'라는 경로를 기준으로 모든 경로가 시작하도록 설계)
- URI를 어떤 방식으로 사용하게 될 것인가라는 고민이 가장 중요
- 외부나 다른 사람에게 메신저 등으로 보낼 수 있게 하려면 반드시 GET 방식으로 처리, '조회'가 가능하도록 만들어야하는 경우는 GET 방식으로 설계
- 현재 사용자가 스스로 작업하는 내용이 있는 경우에 POST 방식으로 처리, 외부에 노출하는 것이 아니라 사용자 본인이 결정해서 어떤 작업이 진행되는 일은 POST 방식으로 처리
- Spring MVC의 경우 어노테이션을 통해 URI를 분기하거나 GET/POST 방식을 지정하기 때문에 URI를 미리 결정해 두는 작업이 필요

* 리다이렉트의 처리 방식
- 등록 작업이 끝나고 리스틑가 보여지기 전 사용자에게 어떤 식으로 등록이 성공했는지 알려줄지?
- 수정이 끝나고 어떤 식으로 결과를 알려주고 리스트로 이동하는지?
- 삭제 작업이 끝나면 어떻게 결과를 알려줄지? 를 고려

* 컨트롤러 선언
1) 스프링 MVC를 이용하는 경우 '@Controller' 어노테이션 추가, @RequestMapping으로 모든 공통 경로를 '/board/'로 인식하도록 설정
2) @Inject 또는 @Autowired로 서비스 객체 주입
3) 등록을 위한 입력 페이지를 보는 경우(GET방식 처리), 실제로 데이터를 처리하는 부분(POST방식 처리) 으로 구분
* GET방식 - 항상 사용자가 직접 브라우저에서 접근이 가능할 때 사용, ex) 입력, 조회 페이지
* POST방식 - 항상 외부에서 많은 정보를 입력하는 경우에 사용, ex) 브라우저상에서 주소창에 보여지면 안 되는 정보를 전송하는데 처리
* Model 클래스 - 스프링 MVC에서 제공하는 데이터 전달용 객체, Map과 유사하게 키,값으로 데이터를 저장하는 역할, Model을 이용해 데이터 저장
4) 컨트롤러의 동작 확인과 루트 경로 지정 (Tomcat 설정의 'modules'메뉴를 이용해 수정)
5) 뷰의 구현 (필요한 jsp 페이지 작성 => jsp 페이지 내에 필요한 데이터 전달 확인 => jsp 페이지 내에서의 출력)

* 등록 작업과 파라미터의 결정
- 스프링 MVC는 메소드의 파라미터와 리턴 타입이 상당히 유연하기 때문에 설계 할 때 결정해야됨
- 파라미터의 수집은 스프링 MVC에서 자동으로 이루어지므로, 파라미터의 수집이 필요하면 원하는 객체를 파라미터로 선언
- 특별한 경우가 아니라면 VO 클래스 혹은 DTO 클래스를 파라미터로 사용
- 브라우저에서 들어오는 요청(request)이 자동으로 파라미터로 지정한 클래스의 객체 속성값으로 처리되는데 이를 바인딩(binding)이라고 함
- 스프링 MVC의 Model 객체는 해당 메소드에서 뷰에 필요한 데이터를 전달하는 용도로 사용, 만일 메소드 내에서 뷰로 전달할 데이터가 있다면, Model을 파라미터로 선언해 주는 것이 편함
- model.addAttribute("변수이름", "변수에 넣을 데이터값");, 뷰(.jsp 파일)에서는 ${}를 이용해서 값을 가져온다.

* RedirectAttributes를 이용한 숨긴 데이터의 전송
- 스프링의 RedirectAttributes객체는 리다이렉트 시점에 한 번만 사용되는 데이터를 전송할 수 있는 addFlashAttribute()라는 기능을 지원함
- addFlashAttribute()는 브라우저까지 전송되기는 하지만, URI상에는 보이지 않는 숨겨진 데이터의 형태로 전달

#4. 전체 목록 구현

* 컨트롤러의 완성 및 JSP의 완성
- Model을 이용해서 모든 게시물을 JSP로 전송하는 작업을 model.addAttribute()로 처리, JSP에서는 JSTL을 사용
- JSTL이란? JSP 표준 태그 라이브러리, 페이지를 작성할 때 유용하게 사용할 수 있는 여러 커스텀 액션과 함수가 포함되어 있는 라이브러리

* 각 목록에 링크 처리하기
- 링크에 대한 처리를 <a> 태그를 이용하거나 경우에 따라서는 JavaScript를 이용하는 것이 더 나은 경우도 있음

#5. 조회 구현

* 구현 순서
1) 조회 기능을 위한 BoardDAO의 처리
2) BoardService, BoardController의 처리
3) 조회 페이지 작성
4) 수정, 삭제 링크 처리

* BoardController의 기능 추가와 뷰 처리
- @RequestParam을 이용해 외부에서 전달될 bno 값을 전달받음, 조회된 결과 게시물을 JSP로 전달해야 하기 때문에 Model 객체 이용
- @RequestParam 어노테이션은 Servlet에서 request.getParameter()의 효과와 유사
- @RequestParam("bno")는 과거 request.getParameter("bno")처럼 동작, Servlet과 다른점은 문자열, 숫자, 날짜 등의 형 변환이 가능
- 스프링의 Model은 addAttribute() 작업을 할 때 아무런 이름 없이 데이터를 넣으면 자동으로 클래스의 이름을 소문자로 시작해서 사용됨 (ex : BoardVO 클래스 객체이므로 boardVO라는 이름으로 저장)

* 조회용 페이지 작성
- 조회 화면의 경우 나중에 수정이나 삭제 작업에서 사용되기 때문에 원래 게시물 번호인 bno를 가지고 있어야 함(from태그에 <input type='hidden'>을 이용해 bno값 처리)

* 수정, 삭제로의 링크 처리 (버튼 처리는 JQuery로)
- 게시물 수정은 별도의 수정이 가능한 페이지로 이동한 후에 처리
- 게시물 삭제는 조회 페이지에서 바로 삭제 처리를 할 수 있도록 처리
- var formObj = $("form[role='form']")는 위에 선언된 <form> 태그를 의미

#6. 삭제/수정 처리

* 삭제 처리
- POST 방식으로 조회 화면에서 처리 (등록과 유사한 부분이 많음)
- 리다이렉트 방식으로 리스트 페이지로 이동시킴, 삭제 결과는 RedirectAttributes의 addFlashAttribute()를 이용해서 처리

* 수정 처리
- 수정할 수 있는 별도의 화명을 제공하는 형태로 제작
- modifyGET()은 GET 방식으로 조회 페이지로 이동, 원래의 게시물 데이터를 읽어와서 Model에 넣어 전달
- modifyPOST()는 POST 방식으로 실제 수정 작업 처리, 저장 버튼을 누르게 되면 POST 방식으로 데이터를 수집하고, 이를 서비스 객체에 전달해서 처리

#7. 예외 처리

* Controller쪽에서 Exception을 처리하기 위해
- @ExceptionHandler 어노테이션 이용, @ControllerAdvice를 이용, @ResponseStatus를 이용한 Http 상태 코드 처리 (두번째 방식)

* @ControllerAdvice 만드는 방식
1) 클래스에 @ControllerAdvice 라는 어노테이션 처리
2) 각 메소드에 @ExceptionHandler를 이용해 적절한 타입의 Exception 처리
- @ControllerAdvice는 호출되는 메소드에서 발생된 Exception을 모두 처리하는 역할을 함
- common() 이라는 메소드를 이용해 Exception 타입으로 처리되는 모든 예외를 처리하도록 설정
- BoardController에서 잘못된 파라미터를 전달하면 error페이지로 이동

* Exception을 화면으로 전달하기
- 발생한 Exception을 화면으로 전달해 주면 개발 시 보다 유용하게 사용가능 (@ControllerAdvice 클래스의 메소드는 발생한 Exception 객체의 타입만을 파라미터로 사용, 직접 ModelAndView 타입을 사용하는 형태로 작성)
* ModelAndView란?
하나의 객체의 Model 데이터와 View의 처리를 동시에 할 수 있는 객체, mv.setViewName("뷰의 경로");, mv.addObject("변수 이름", "데이터 값");, ModelAndView 객체를 반환한다.
- errorModelAndView()에서는 내부적으로 ModelAndView의 객체를 생성하고 반환하도록함

#8. 페이징 처리 - 영속(persistence 계층, 비즈니스 계층

* 페이징 처리 접근 방법
- 사용자에게 필요한 만큼의 데이터를 전송해야함, 서버에서 최대한 빠르게 결과를 만들어 내야 함
1) URI의 문자열을 조절해서 원하는 페이지의 데이터가 출력되도록 하는 단계
- 페이지 번호 등을 파라미터로 전달하고, 이를 이용해서 SQL에 적절한 데이터를 뽑아서 보여주는 단계, 오직 페이지 번호에 해당하는 데이터를 출력하는 것
2) 목록 페이지 하단에 페이지 번호를 보여주고, 클릭하면 페이지가 이동하는 단계
- 원하는 페이지의 데이터를 구하는 작업, 화면하단에 페이지를 출력해 주는 작업, 이전 이나 다음에 대한 처리, 시작 페이지 번호와 끝 페이지 번호에 대한 계산도 같이 처리
3) 목록 페이지에서 조회나 수정 작업을 한 후에 다시 원래의 목록 페이지로 이동할 수 있게 처리하는 단계

* 페이징 처리 방식
- 모든 작업에 필요한 리스트를 보는 데 필요한 정보가 같이 유지돼야만 한다는 점
1) <a> 태그의 href 속성을 이용해 직접 이동할 URI를 지정하는 방식
- 검색엔진에 노출이 쉬워진다는 점, 한 번에 모든 연결정보를 파악할 수 있다는 장점이 생김, 많은 양의 반복적인 링크 정보가 생성
2) <form>태그를 이용해 링크를 클릭하면 여러 정보를 전달하는 방식
- 링크에 최소한의 정보를 이용, 빠르게 개발 가능, 필요한 정보를 클릭하는 경우 <form> 태그 내에 필요한 정보를 담아 처리하는 방식

* 페이징 처리의 원칙
1) 페이징 처리는 반드시 GET 방식만을 이용해 처리
2) 페이지는 다른 사람에게 URL로 전달하는 경우가 많기 때문에, 반드시 GET 방식으로만 처리
3) 페이징 처리가 되면 조회 화면에서 반드시 '목록 가기'가 필요
4) 목록 페이지에서 3페이지를 보다 특정 게시물을 보았다면, 다시 '목록가기' 버튼을 눌러 3페이지로 이동하는 기능 구현되야 함
5) 페이징 처리에는 반드시 필요한 페이지 번호만을 제공
6) 한 페이지에 10개씩 데이터를 출력하는 경우라면, 전체 데이터가 32건 있을 때 4페이지만 화면에 출력돼야 함, 더 많은 데이터가 있을 때에는 적당한 수의 페이지 번호를 출력하고, 뒤로 가는 화살표 등을 이용해 보여줘야 함

* 페이징 처리 개발에 필요한 지식
- 페이징 처리, 데이터 개수 파악을 위한 SQL, 자바스크립트 혹은 <a> 태그를 통한 이벤트 처리

* MySQL의 limit를 이용한 페이지 출력 SQL
- 가장 중요한 점은 빠른 데이터의 출력을 위해 가능하면 결과의 양을 적게 유지하는 것이 좋음, 페이지당 10개 데이터를 출력한다면, 페이지 번호에 맞는 데이터를 가져올 때 필요한 10개 데이터만 가져와야 함
- MySQL의 경우 전체 데이터 중에서 일부분의 데이터만 출력하고 싶을 때는 limit구문을 이용해 처리 (select ... where ... order by... limit 시작데이터, 데이터의 개수)

* 페이징 처리 순서
1) MyBatis의 BoardDAO 처리 - BoardDAO, XML Mapper, BoardDAOImpl 처리
2) 페이징 처리의 SQL 테스트 
- 만일 한 페이지에서 보여지는 데이터가 10개가 아니라면 limit 구문의 마지막에 사용되는 10이라는 숫자가 변경될 필요가 있고, 매번 원하는 페이지를 처리할 때마다 계산을 해야 하는 불편함 떄문에 파라미터를 두개 받는 방법 사용
3) DAO 처리 도와줄 Criteria 클래스 만들기
- #{page}와 같은 파라미터를 사용할 때 내부적으로 page 속성의 getter에 해당하는 getPage()메소드를 호출, SQL문에 파라미터가 여러 개로 늘어나면 관리하기 어려워지기 때문에 아예 클래스로 만들어서 객체로 처리
- 이 글래스의 사전적인 의미로는 검색 기준, 분류 기준에 해당함, 객체 내부에 페이지 번호와 페이지 당 보여지는 개수 속성을 보관
- getPageStart()는 limit 구문에서 시작 위치를 지정할 때 사용, 시작 데이터 번호 = (페이지 번호 - 1) * 페이지 당 보여지는 개수
4) BoardDAO, XML Mapper, BoardDAOImpl, BoardService 수정

#9. 페이징 처리 - 컨트롤러와 프레젠테이션 계층

* 페이징 처리 순서
5) 컨트롤러에 적절한 메소드를 만들고, 적당한 파라미터를 넣어 호출 (특정 URL에 해당하는 메소드를 실행할 때 파라미터의 타입을 보고 해당 객체를 자동으로 생성)
6) 1차 화면 테스트(jsp)
7) 화면 하단의 페이징 처리 (화면 하단에 나오는 페이지 번호가 출력되는 작업)
- 시작 페이지 번호(startPage) : 화면상 10개의 페이지 번호를 출력한다고 했을 때, 현재 페이지가 1~10 사이에 있는 번호라면 시작 페이지는 1, 1이 아니라면 '이전'으로 갈 수 있는 링크가 제공되어야 함
- 끝 페이지 번호(endPage) : 시작 페이지 번호부터 몇 개의 번호를 보여줘야 하는지 결정해야함, 이때 영향을 미치는 것이 전체 데이터의 개수
		          예를 들어 전체 데이터가 65개이고 현재 페이지가 5페이지면 시작 페이지 번호는 1이고, 끝 페이지 번호는 7(65개이므로 7페이지까지 표시)
- 전체 데이터 개수(totalCount) : 끝 페이지 번호를 계산할 때 전체 데이터의 개수를 이용해 최종적으로 끝 페이지의 번호가 결정, 끝 페이지 번호보다 많은 양의 데이터가 존재 한다면 '뒤로' 갈 수 있는 링크 추가
- 이전 페이지 링크(prev) : 맨 앞의 페이지 번호가 1이 아니라면 화면상 링크를 통해 이전 페이지를 조회할 수 있어야 
- 이후 페이지 링크(next) : 맨 뒤의 페이지 이후에 더 많은 데이터가 존재하는 경우 이동이 가능하도록 링크 제공
* 계산 순서
- 한 페이지에 몇 개의 데이터를 보여주는지(perPageNum) 결정돼 있어야 함
- 페이지 번호를 몇 개씩 보여주는지 결정돼 있어야 함, 일반적으로 10개씩 화면에 페이지 번호를 보여주는 경우가 많음
- 페이지의 계산 : 현재 페이지가 13p인 경우 startP는 11p, endP는 20p
- 13/10(페이지 번호를 몇 개씩 보여줄 수) = 1.3
- 1.3 올림 = 2
- 2의 의미는 페이지 번호 10개씩 두 번재로 보여지는 페이지라는 것, 화면상 페이지 번호는 11~20p
- 2 * 10(페이지 번호 수의 개수) = 20
- 20은 endP의 번호
- 20 - 9 = 11 (startP 번호)

*1) endPage 구하기 (현재 페이지 번호를 기준으로 계산)
- (현재 페이지 번호 / 페이지 번호의 수) * 화면에 보여지는 페이지 번호의 수
*2) startPage 구하기
- (마지막 페이지 - 페이지 번호의 수) + 1
*3) totalCount와 endPage의 재계산
- endPage는 실제 데이터의 개수와 관련이 있기 때문에 다시 한 번 계산 (100개의 데이터를 10개씩 보여준다면 endP는 10, 20개씩 보여준다면 endP는 5)
 - 이전에 구한 endPage 값과 계산된 결과를 비교해서 계산된 결과가 작은 경우 실제 endPage는 최종 계산된 결과가 돼야함
*4) prev와 next 계산
- prev의 경우 startP가 1이 아닌지 검사, 삼항연산자를 이용해 1이면 f, 아니면 t 값을 가져옴
- next의 경우 endPage * perPageNum이 totalCount보다 작은지 확인 (perPageNum이 10, endPage가 10인 상황에서 totalCountrk 101이라면 next는 t)
8) 페이징 처리용 클래스 설계 (모든 페이징 처리가 필요한 화면에서 쉽게 사용할 수 있음)
9) BoardController와 뷰 처리 (listPage()에서는 크게 목록 데이터를 Model에 저장하는 작업과 PageMaker를 구성해서 Model에 담는 작업이 이루어짐)
10) listPage 뷰(jsp) 처리 (페이지의 번호들이 제대로 출력이 되는지)
11) 페이징을 위한 SQL문의 처리 (DAO, XML, Service, Controller 수정)
- 실제 게시물의 숫자를 이용해서 페이지를 처리할 수 있게 처리
12) 페이징 처리 개선 (page파라미터 외 perPageNum 파라미터까지 전달 해줘야 함)
- 직접 JSP 내에서 수정하는 방법, PageMaker에서 필요한 링크를 생성해 주는 방법, JavaScript를 이용해 처리하는 방법
13) PageMaker에 간단한 메소드를 추가
* URI를 작성할 때 도움되는 클래스
- UriComponents 클래스 : path나 query에 해당하는 문자열들을 추가해 원하는 URI를 생성할 때 사용
- UriComponnentsBuilder : 특정 URI를 먼저 지정하고 작업하는 것도 가능
* JavaScript를 이용하는 링크의 처리
- 링크에는 단순히 페이지 번호만을 넣고, 모든 것은 <form>과 JavaScript를 이용해 처리
- 페이지 번호가 클랙되면 event.preventDefault()를 이용해 실제 화면의 이동을 막고, <a> 태그에 있는 페이지 번호를 찾아 <form> 태그를 전소하는 방식을 이용
* event.preventDefault() : 현재 이벤트의 기본 동작을 중단
- 반복적인 개발이 많은 경우에 적은 양의 코드로 개발이 가능
14) 목록 페이지와 정부 유지하기 (특정한 페이지를 보다가 조회 페이지로 이동하는것에 대한 처리, 조회 페이지에서 다시 목록보기를 이용해 기존에 자신이 보던 목록 페이지로 전환되어야 함)
- 페이징 처리가 된 후, 조회 페이지는 다시 목록 페이지로 돌아가기 위해 '현재 목록 페이지의 페이지 번호(page) 와 현재 목록 페이지의 페이지당 데이터의 수(perPageNum), 현재 조회하는 게시물 번호(bno)'를 알아야 됨
15) 수정 페이지와 삭제 페이지의 처리
* 삭제 처리
- 사용자가 보던 페이지의 정보가 유지되면서 삭제 후 다시 해당 페이지로 이동해야 됨
* 수정 처리
- 수정 버튼 클릭 후 수정 화면으로 들어가고 수정 작업이 완료되면 원래의 목록 페이지로 이동해야 함
- 모든 작업이 끝나면 다시 목록 페이지로 리다이렉트 되어야 하고, 수정된 결과에 대해 msg로 전송
- 수정이 가능한 화면에서는 POST 방식으로 수정으로 요청하게 되고 작업이 완료된 후에는 원래의 정보가 유지된 채로 목록 페이지로 이동

#10. 검색 처리와 동적 SQL (목록 페이지에서 검색 조건과 키워드를 입력하고, 이에 맞는 검색 데이터를 추출해 보여주는 작업)
- MyBatis를 이용하는 SQL 문의 처리 영역은 동적 SQL을 이용하거나 @SelectProvidr라는 것을 이용

* 검색 처리 순서
1) 검색에 필요한 데이터와 SearchCriteria 클래스 작성
- 유지되어야 하는 정보 (현재 페이지 번호(page), 페이지당 보여지는 데이터의 수(perPageNum), 검색의 종류(searchType), 검색 키워드(keyword))
- 기존 Criteria에 종류, 키워드를 추가해서 구현하는 것도 좋지만 별도 클래스인 SearchCriteria을 기존 Criteria를 상속해 사용(PageMaker에서도 그대로 사용)
2) 컨트롤러 작성
3) JSP 페이지의 준비 (검색에 필요한 화면 구성 - 검색 종류, 검색 키워드)
- SearchCriteria에 searchType 속성이 존재하므로 이를 이용해 화면상의 <select> 태그 조절, keyword는 <input type>으로 처리
4) seachType과 keyword 링크 처리
- PageMaker에서 적당한 URI에 사용할 문자열(query string)을 생성, UeiComponents를 이용해 페이징 처리에 필요한 데이터를 생성하는 역할을 함
5) 검색 버튼의 동작 처리
- 새로운 검색을 시도하는 경우에만 검색 버튼 사용, 검색 버튼의 클릭은 1페이지의 데이터를 의미
* self.location : 현재 창 변경 (페이지 이동)
- makeQuery() 사용 : 검색 조건이 없는 상황에서 사용하는 메소드, 검색 조건이 없는 링크를 생성하고, 필요한 링크를 뒤에 연결 시키는 방식으로 처리

* myBatis 동적 SQL
- 화면에서의 검색 조건에 따라 검색해야 하는 SQL 문이 달라지기 때문에 이를 처리하기 위해 MyBatis에서 사용하는 Mapper에서 SQL을 사황에 맞게 처리할 수 있는 기능이 필요 => 동적 SQL 기능
- 몇 개의 태그와 표현식을 가지고 있음
- if : 코드로 작성할 때의 if 구문에 대한 처리
- coose(when, otherwise) : switch와 같은 상황에 대한 처리
- trim(where, set) : 로직을 처리하면서 필요한 구문을 변경
- foreach - 컬렉션에 대한 순환 처리
- MyBatis에서 사용하는 SQL문을 어노테이션을 이용해서 처리하는 경우보다 XML로 관리하는 형태가 압도적으로 많은 이유는 동적 SQL을 어노테이션으로 처리하기 복잡하기 때문
- 동적 SQL 개발 순서
*1) 동적 SQL의 적용이 필요한 메소드의 생성
*2) XML Mapper를 이용한 SQL문 처리
*3) 동적 SQL문의 생성 확인 및 테스트

6) DAO, XML Mapper, DAOImpl 수정 및 테스트
- 동적 SQL 문을 적용하기 위한 메소드를 설정
- page(Criteria 상속), perPageNum(Criteria 상속), searchType(SearchCriteria), keyword(SearchCriteria) 4개의 데이터 유지
- 확실히 동작하는 SQL문을 먼저 실행한 후 동적인 부분을 처리하는 것이 좋음
7) 동적 SQL문 추가
- MyBatis의 <if>를 이용해 검색 조건에 따른 동적 SQL문 추가
- <if test>는 test 속성에 있는 표현식이 boolean으로 나오는 결과여야 함, 검색할 조건이 있는 경우에는 equals() 테스트 진행
- 검색 조건들은 SQL의 like 구문으로 검색되어야 하고, OR 조건이나 AND 조건이 들어가기 때문에 '()'를 이용해 우선 순위 부여
* <include>와 <sql>
- 동일한 SQL 구문을 <include>를 이용해 재사용할 수 있음
- <sql>을 이용해 SQL을 조각낼 때 반드시 id 속성을 이용해 적당한 이름을 가지도록 함
8) Service와 Controller 수정
9) 조회, 수정, 삭제 페이지의 처리 (조회, 삭제, 수정페이지의 처리 시에도 검색타입과 검색어가 같이 전송되는 형태로 동작해 주어야함)
10) 등록 페이지 처리