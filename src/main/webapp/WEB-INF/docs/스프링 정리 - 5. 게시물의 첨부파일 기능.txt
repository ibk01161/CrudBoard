PART5. 게시물의 첨부파일 기능

#1. 스프링 MVC의 파일 업로드
- 파일 업로드는 일반적인 <form> 태그와 비교하면 전송되는 데이터의 구성이 다르기 때문에, 일반적인 방법으로는 처리X
- 스프링의 경우 개발자가 이러한 불편함을 줄일 수 있도록 파일 업로드에 필요한 기능을 지원하지만, 약간의 설정과 라이브러리 필요

* 파일 업로드의 활용
- 'JPG, GIF, PNG'와 같은 이미지 파일과 그렇지 않은 일반 파일들을 서버에 저장하고, 다른 사용자들이 보거나 다운로드 할 수 있도록 구현
- 사용자가 게시물을 등록할 때 원하는 파이를 Drag & Drop을 이용해 원하는 파일을 업로드 할 수 있음, 이때는 사용자가 직관적으로 사용할 수 있도록 Ajax를 이용해 업로드를 처리
- 업로드 된 파일은 아래쪽에서 확인할 수 있고, 이미지 파일의 경우에는 원래 이미지보다 작은 이미지 파일(썸네일)을 생성해 처리
- 사용자가 업로드 한 파일이 이미지인 경우 바로 화면에서 이미지를 볼 수 있지만, 일반 파일인 경우는 파일이 자동으로 다운로드 되도록 작성
** 서버에서는 업로드와 관련해 이루어지는 작업
1) 사용자가 업로드 하는 시간에 따른 자동적인 폴더 생성
2) 업로드 되는 파일의 고유한 이름 생성
3) 이미지 파일의 업로드 시 썸네일 이미지를 생성
4) 이미지 파일의 경우 서버에서 저장된 파일을 읽어 적당한 MIME 타입으로 서비스
5) 일반 파일의 경우 다운로드 타입으로 파일 데이터 서비스

* 파일 업로드 순서 (일반적 파일 업로드)
1) 라이브러리 추가
- 이미지 파일의경우 이미지를 깨끗하게 축소할 수 있는 imgScalr 라이브러리를 활용, 파일 업로드를 위해 common-fileuplad 라이브러리 추가
2) 파일 업로드 관련 <bean> 설정
- 웹에서 파일 업로드는 일반적으로 'multipart/form-data'라는 방식으로 데이터를 전송
- 스프링 MVC에서 파일 업로드를 처리하기 위해 파일 업로드로 들어오는 데이터를 처리하는 객체가 필요
- 스프링에서 multipartResolver라고 하는 이 객체의 설정은 웹과 관련 있기 때문에 servlet-context.xml을 이용해 설정
- CommmonsMultipartResolver에는 많은 설정이 존재하지만 우선적으로 업로드에 필요하기 때문에 스프링의 빈으로 등록, property중에서 maxUploadSize속성은 업로드의 크기를 제한 하는 속성
3) 업로드 컨트롤러와 JSP 작성
- 일반적인 파일 업로드는 화면에 파일을 선택하는 <input type="file">을 만들고 원하는 파일을 선택해 업로드 하는 형태
- JSP에서 <form>의 enctype 속성값인 'multipart/form-data'는 일반적 <form> 방식과 다르게 multipart방식으로 데이터가 전달된다는 것을 의미
4) POST 방식의 파일 업로드 처리
- Multipart로 구성된 데이터의 처리는 프로젝트의 시작단계에서 적용한 multipartResolver 설정을 통해 처리, MultipartFile 타입을 선언하고, MultipartFile은 POST방식으로 들어온 파일 데이터를 의미
- MultipartFile 객체를 이용하면 전송된 파일의 이름이나 크기 그리고 MIME 타입 등과 같은 정보들을 추출 할 수 있음
- 파일을 입력하는 화면에서 한글 이름의 파일을 업로드 하고 출력한 파일의 이름이 깨지면 web.xml에 한글 처리용 필터를 적용
5) 업로드 파일의 저장 (컴퓨터 하드 상의 특정한 경로를 이용해 저장)
- 스프링 MVC의 파일 업로드는 업로드 된 파일의 정보를 읽고 업로드 된 파일을 서버의 특정한 위치에 저장하는 순서로 이루어짐
- 업로드 된 파일의 보관은 파일 시스템을 사용하는 경우도 있고, 데이터베이스를 이용하는 경우도 있음
- 데이터베이스에 보관하는 경우 보안이나 안정성은 좋아지지만, 서비스 할 때 데이터베이스에서부터 읽어야 하는 등 성능상에 문제가 있을 수 있음
* 서버의 파일 저장 경로 설정
- 파일을 저장할 경로는 상수처럼 사용되기 때문에 servlet-context.xml 파일을 이용해 특정 경로를 문자열로 설정함
- uploadPath라는 id를 가진 문자열이 스프링 빈으로 설정, 문자열 값은 경로를 문자열로 지정해 둠, 작성된 경로의 문자열은 UploadController에 주입해 사용
- 설정된 경로를 이용하고, 파일을 저장하는 코드는 컨트롤러를 수정해서 처리
- uploadFile()은 원본 파일의 이름과 파일 데이터를 byte[]로 변환한 정보를 파라미터로 처리해서 실제로 파일을 업로드함
- UUID는 중복되지 않는 고유한 키 값을 설정할 때 사용, UUID는 고유한 값을 생성해 처리하기 때문에 동일한 경로에 동일한 이름의 파일을 업로드 하는 문제를 피할 수 있음
- 실제 파일 이름은 중간에 '_'를 이용해 파일의 이름 완성, 실제 업로드 된 결과를 보면 UUID 값이 앞에 존재하고 '_' 이후에 실제 파일 이름이 존재
- uploadFile() 내부에서 실제 파일 처리는 스프링에서 제공하는 FileCopyUtils를 이용
- FileCopyUtils는 'org.spirngframework.util' 패키지에 설정된 클래스, 파일 데이터를 파일로 처리하거나 복사하는 등 작업에 유용하게 사용, 이 패키지의 경우 개발자가 개발하면서 필요한 여러 종류의 클래스를 제공
- FileCopyUtils 클래스의 모든 static 메소드는 copy()이고 데이터가 담긴 바이트의 배열을 특정한 OutputStream으로 전송하는 역할을 함, 데이터가 보관된 byte[]나 InputStream이 존재하는 경우 유용하게 사용
- 실행 후 업로드를 실행하면 해당 경로에 고유한 UUID 값이 붙은 첨부파일이 생김
6) <iframe>을 이용한 파일 업로드의 결과 처리
- 최근의 게시물들은 게시물을 작성할 때 내용과 별개로 파일을 필요할 때마다 추가하는 형태가 일반적, 업로드 된 결과 역시 현재의 창에서 바로 사용할 수 있도록 하는 것이 좋음
- 문제는 <form> 태그의 경우 브라우저에서 전송이 일어나기 때문에 화면 전환을 피할 수 없는데, <form>태그에 target속성을 주고, <iframe>을 이용하면 화면 전환 효과를 없앨수 있음
* <iframe>을 이용해 파일을 업로드 하는 방법
1) <form> 태그의 전송은 화면에 포함된 <iframe>으로 전송
2) 결과 페이지는 <iframe> 내에 포함되므로 화면의 변화 없음
3) 결과 페이지에서 다시 바깥쪽(parent)의 JavaScript 함수 호출
------------------------------------------------------------------------------
7) 컨트롤러 수정 및 결과 페이지 작성
- 결과 페이지는 <iframe> 내에서 동작하기 위해 작성된 페이지, 화면을 구성하는 부분 없이 <script>를 사용해서 자신이 속한 화면의 바깥쪽 parent의 addFilePath() 함수를 호출
8) <iframe>으로 <form> 데이터 처리 (<form> 태그의 전송은 <iframe>을 이용해야하므로 입력화면 jsp 수정)
- <iframe>, <form> 태그의 target 속성 추가, <script> 태그 내 작성된 addFilePath()는 결과화면에서 호출하는 부모창(parent)의 함수, ajax와 유사하게 화면 이동이 없는 상태에서 업로드 된 결과를 볼 수 있음
- <iframe>을 사용하는 방식은 숨겨진 페이지를 이용해 <form>의 submit()을 실행하고, 숨겨진 페이지가 바깥쪽의 페이지 함수를 호출하는 형태

* 파일 업로드 순서 (Ajax 방식)
- 파일을 탐색기에서 선택하고 끌어 놓으면 파일이 자동으로 Ajax를 이용해 업로드 하는 예제 (단일 파일 업로드)
1) Ajax 업로드용 컨트롤러와 JSP 작성
- JSP에서 파일을 드롭(drop) 할 수 있는 <div>를 하나 만듦
- <script>이후 JQuery를 이용하는 JavaScript 부분을 보면 'dragenter, reagover, drop'시 기본 동작을 막도록 설정돼있음, 브라우저에 파일을 끌어다 놓아도 아무런 동작을 하지 않도록 막아주는 기능을 함
- 이벤트 처리 제한(preventDefault)를 하지 않으면 파일을 끌어다 놓으면 새로운 창이 열리고, 파일이 보이게 됨, 할 경우 파일을 끌어다 놓아도 아무런 변화가 없음
2) 이벤트 처리하기
- 파일이 실제로 드롭 되었을 때 어떤 동작이 일어나야 하기 때문에 'drop'과 관련된 이벤트 처리를 해야함
- 이벤트 처리의 핵심적인 부분은 dataTransfer.files의 부분으로, 전달된 파일 데이터를 가져오는 부분, event.originalEvent는 event가 순수한 DOM 이벤트가 아니기 때문에 순수한 원래 DOM 이벤트를 가져옴
- event.dataTransfer는 이벤트와 같이 전달된 데이터를 의미하고, 그 안에 포함된 파일 데이터를 찾아내기 위해 dataTransfer.files를 이용
- 콘솔에 출력되는 내용은 Drop이 이루어진 파일에 대한 정보를 읽어냄, type 정보가 있기 때문에 해당 파일이 이미지 파일인지 일반파일인지 구분할 수 있고, 파일 이름, 크기에 대한 정보도 알 수 있음, 이러한 정보로 제한 가능
3) FormData를 이용한 서버 호출
- Ajax는 전통적인 <form>태그와는 다르기 때문에 과거에는 주로 문자열을 전송할 때 사용했었지만, HTML5에서 지원하는 FormData 객체를 이용하면 <form>태그로 만든 데이터의 전송 방식과 동일하게 파일 데이터를 전송 가능
- FormData를 사용하는 방법은 객체를 생성하고, 필요한 데이터 '이름'과 '값'을 추가하면 됨, 만들어진 FormData에 append()를 이용해 'file'이름으로 끌어다 놓은 파일 객체를 추가함
4) Ajax 처리하기
- Ajax를 POST방식으로 이용하지만 $.post()를 사용하지 않고 $.ajax()를 이용해 여러 가지 옵션을 지정함
- $.ajax()를 이용해 FormData 객체에 있는 파일 데이터를 전송하기 위해서 'processData'와 'contentType'옵션을 반드시 false로 지정, 이 옵션들은 데이터 전송을 <form> 태그를 이용하는 파일 업로드와 동일하게 해주는 역할을 함
* processData : 데이터를 일반적인 query String으로 변환할 것인지 결정, 기본값은 true로 'application/x-www-form-urlencoded' 타입으로 전송, 다른 형식으로 데이터를 보내기 위해 자동 변환을 하지 않을 경우 false로 지정
* contentType : 기본값은 'application/x-www-form-urlencoded', 파일의 경우 multipart/form-data 방식으로 전송하기 위해 false로 지정
5) 컨트롤러에서 Ajax 처리하기
- 파일 업로드 하는 '/uploadAjax' 처리를 컨트롤러에서 진행
- @RequestMapping의 속성으로 produces 속성을 지정하는 것은 한국어를 정상적으로 전송하기 위한 설정
- ResponseEntity를 전송하는 부분에서 'HttpStatus.CREATED' 값은 원하는 리소스가 정상적으로 생성되었다는 상태 코드임
- 실행해보면 전송될 때 데이터가 일반적인 경우와 달리 <form> 데이터를 전송할 대와 동일하게 동작

#2. 전송된 파일의 저장
* 서버에서 파일을 저장할 때 반드시 고려해야 하는 사항
- 파일 이름의 중복 문제, 파일의 저장 경로에 대한 문제, 원본 파일을 그대로 보여주는 경우 브라우저에서 보여지는 파일의 크기 문제
- 파일 이름 중복 문제는 UUID로 해결 가능
* 파일 경로를 고려해야 하는 이유
- 특정 폴더에 파일을 업로드하게 되면 너무나 많은 파일을 같은 경로에 쌓이게 하기 때문 => 속도 저하와 파일 개수 제한에 걸릴 수 있음, Linux는 폴더 내 파일 수를 조절할 수 있지만, 속도 저하가 있음
- 해결책은 파일을 저장할 때 '/년/월/일'을 별도의 폴더로 구성해 파일을 보광하는 것
* 파일 크기 문제
- 브라우저에 올리는 이미지는 용량이 큰 경우가 많은데, 많은 양의 파일이 한 화면에 보여지게 되면 브라우저는 많은 양의 데이터를 받아야 하기 때문에 바람직하지 못함
- 최소한의 데이터를 전송하기 위해 썸네일 이미지라는 원본 이미지 파일의 축소본을 만들어 전송

* 파일 업로드 순서 (자동적 폴더 생성, 이름 UUID 처리, 썸네일 이미지 생성 기능)
1) 파일 업로드용 클래스와 업로드 기능 설계
- util 패키지를 생성하고 새로운 클래스 설계
- UploadFileUtils는 스프링의 FileCopyUtils와 유사하게 static 기능을 호출해 파일을 업로드 할 수 있도록 설계
- 파일 업로드 하기 위해 파일의 저장 경로, 원본 파일 이름, 파일 데이터 와 같은 3개의 데이터가 필요, 위 3개 데이터를 파라미터로 전송 받는 uploadFile() 함수 작성, 별도 데이터가 보관될 필요가 없기 때문에 static으로 설계
2) 업로드 폴더의 생성 처리
- UUID를 이용한 고유 값 생성 => UUID와 결합한 업로드 파일 이름 생성 => 파일이 저장될 '/년/월/일' 정보 생성 => 업로드 기본 경로와 폴더 생성 => 기본 경로 + 폴더 경로 + 파일 이름으로 파일 저장 의 과정으로 진행
- calcPath()의 리턴 값은 최종 결과 폴더를 반환, 내부적으로 폴더를 생성해 주는 기능이 필요하기 때문에 기본적인 경로(uploadPath)를 파라미터롤 전달받음, Calendar 클래스를 이용해 현재 날짜 데이터를 얻어냄
- 얻어낸 날짜 정보는 기본 경로와 함께 makeDir()에 전달되어 폴더가 생성됨
* File.separator - 파일 구분자 "/", OS마다 파일 구분자가 다른데 separator을 써주면 해결
3) 썸네일 생성하기
- 업로드 되는 파일은 크게 브라우저에서 보여지는 이미지 종류의 파일(JPG, GIF, PNG)과 사용자가 다운로드 하는 형태의 파일로 구분
- 업로드 된 파일의 저장은 서버로 업로드 된 모든 파일의 공통적인 사항이지만, 썸네일은 이미지 타입의 파일에만 해당 사항이 있음
- 이미지 타입의 이름인 경우 결과적으로 브라우저가 찾아야 하는 파일은 썸네일 이미지의 이름과 경로가 돼야 하고, 그렇지 않으면 저장된 파일의 이름과 경로가 필요
- 저장한 파일이 이미지 타입의 파일일 경우 => 썸네일 이미지 생성 => 생성된 썸네일 파일 이름 반환, 아닐경우 => 생성된 파일 이름 반환
- 썸네일을 생성하는 코드는 imageScalr 라이브러리 활용, pom.xml에 라이브러리 추가, UploadUtils에 썸네일 생성 코드 추가
- 썸네일을 생성하는 작업은 메소드의 파라미터에 사용된 (기본경로, 년/월/일 폴더, 현재 업로드 된 파일의 이름)을 이용
- BufferedImage는 실제 이미지가 아닌 메모리상의 이미지를 의미하는 객체, 원본 파일을 메모리상으로 로딩하고, 정해진 크기에 맞게 작은 이미지 파일에 원본 이미지를 복사함, FIT_TO_HEIGHT는 높이를 지정된 100px로 만들어주는 역할
- 썸네일 이름에는 UUID 값이 사용된 이후 반드시 s_로 시작하도록 설정, 이유는 s_로 시작하면 썸네일 이미지고, 없으면 원본 파일의 이름이 되도록 하기 위해서임
* 메소드의 리턴 시 문자열을 치환하는 이유 - 윈도우의 경로로 사용하는 '\'문자가 정상적인 경로로 인식되지 않기 때문에 '/'로 치환
4) 저장한 파일이 이미지 파일일 경우 클래스 만들기
- jpg, gif, png만 처리하므로 이미지 타입을 식별할 수 있는 기능을 별도의 MediaUtils 클래스로 작성
- MediaUtils는 확장자를 가지고 이미지 타입인지를 판단해 주는 역할, 별도의 클래스로 구성한 이유는 브라우저에서 파일을 다운로드 할 것인지, 보여줄 것인지를 결정하기 위해서 만듬
- savedPath는 저장될 경로를 계산함, FileCopyUtils.copy(fileData, target)은 원본 파일을 저장하는 부분
- formatName은 원본 파일의 확장자를 의미 이를 MediaUtils클래스의 getMediaType()을 이용해 이미지 파일인 경우와 그렇지 않은 경우를 나누어 처리
- 이미지 파일인 경우에는 썸네일을 생성하고, 그렇지 않은 경우에는 makeIcon()을 통해 결과를 만들어 냄, makeIcon은 경로 처리를 하는 문자열의 치환용도에 불과함
5) 컨트롤러 수정
- 최종 리턴 값은 내부적으로 UploadFileUtils의 uploadFile()을 사용하도록 수정
- 다시 '/uploadAjax'를 호출하면 모든 첨부파일이 '/년/월/일'로 시작하는 문자열을 전달받음
- 썸네일이 생기는 이미지 파일의 경우 파일의 저장 경로에는 자동으로 '/년/월/일' 폴더가 생성, 원본 파일과 썸네일 파일이 생성
- 이미지 타입이 아닌 파일이면 결과 메시지에 's_'로 시작되지 않고, 저장 경로에도 파일은 하나만 생성

#3.전송된 파일을 화면에 표시하기
- Ajax로 파일의 이름이 전송된 후 이를 화면에 출력해 줘야함
- 이를 위해 파일 이름을 가지고 화면에 태그를 생성해서 추가하는 작업과 컨트롤러에서 특정한 경로의 파일 데이터를 전송하는 작업이 진행되야 함
- 먼저 처리해야 할 것은 특정한 URI를 호출했을 때 업로드 된 파일이 제대로 보이는지를 처리하는 일임

* 파일 데이터 전송하기
- UploadController는 필요한 경우 특정 경로의 파일을 다시 브라우저로 전송해 주는 기능이 필요
- 주의할 점은 파일 데이터를 보내 줄 때 이미지 파일인 경우 적절한 포맷에 맞는 MIME 타입을 지정해 줘야 하고, 일반 파일 경우는 다운로드를 할 수 있도록 처리해야 됨

* UploadController의 파일 전송 기능 구현

* JSP에서 파일 출력하기
- Ajax로 호출된 결과를 위와 같은 이미지나 파일의 링크로 생성하면 사용자가 업로드 한 파일을 다운로드 하거나 확인할 수 있음
1) Ajax의 결과로 전송된 파일이 이미지 타입의 파일인지 구분
2) 이미지 타입인 경우 <img>태그 생성, 만들어진 <img> 태그를 원하는 요소에 넣어줌
3) 이미지 타입이 아닌 경우 <div> 태그와 <a> 태그를 이용해 처리
- 전송 받은 문자열이 이미지 파일인지 확인하는 작업은 함수를 만들어 처리 (정규표현식을 이용해 파일의 확장자가 존재하는지 검사, i의 의미는 대 소문자 구분 없음)
- 파일을 업로드 하면 이미지 파일의 경우에는 아래쪽 썸네일에 이미지가 보이고, 일반 파일의 경우는 파일 이름만 출력

* 파일 링크 처리
- 일반 파일의 이름이 너무 길게 출력되는데 이를 줄여주는 기능 작성
- 함수를 만들어 첨부파일의 이름이 UUID와 첨부파일의 이름이 결합될 때 '_' 가 사용되는 것을 이용해 원래 파일 이름만 추출
- 이미지가 아닌 경우 정상적으로 이름이 보여지고, 다운로드가 가능한 상태가 됨

* 이미지 파일의 원본 파일 찾기
- 첨부파일이 이미지인 경우 다운로드가 아닌 실제 원본 이미지 데이터를 가져와야만함, 보여지는 이미지는 썸네일이므로 중간에 's_'를 제거하면 원래 이미지 파일이 됨
- fileName.substr(0,12)는 '/년/월/일' 경로를 추출, fileName.substr(14)는 파일 이름 앞에 s_를 제거하는 용도로 사용
- 화면에서 썸네일 이미지를 클릭하며 우너본 파일을 조회하는 링크로 이동

#4. 첨부파일의 삭제
- 첨부파일을 삭제하는 작업은 첨부파일의 이름을 전달해서 처리, 화면에서 삭제를 선택할 수 있는 버튼을 만들어서 작업

* UploadController의 삭제 처리
- 화면에서 'x'를 선택해 첨부파일을 삭제하고자 한다면, 실제 저장 경로에서도 파일이 삭제돼야함
- deleteFile()은 파라미터로 삭제할 파일의 이름을 받아들임, 이미지의 경우는 썸네일 이름이고, 일반 파일은 실제 이름, 이미지 파일이면 원본 파일을 먼저 삭제하고, 이후 파일 삭제하는 방식으로 작성

* JSP에서 첨부파일 삭제 처리
- JSP에서 Ajax를 이용해 파일의 이름을 컨트롤러에 전달해야 함
- 사용자가 <small> 태그로 처리된 'x'를 클릭하면 'data-src' 속성값으로 사용된 파일 이름을 얻어와서 POST방식으로 호출
- 이벤트 처리를 했을 경우 실제 폴더에서 파일이 삭제되는지 확인

* 파일 삭제 후 화면에서의 제거
- 파일 서버에서 정상적으로 삭제됐다는 메세지를 전달 받으면 화면에서 첨부파일을 보여주기 위해 만들어진 <div>가 삭제돼야함, JQuery의 remove()를 이용해 요소 삭제

#5. 게시물 등록의 파일 업로드
- 파일 업로드 방식
1) <form>태그와 같이 전송하는 방식 : 사용자가 <input tpye='file'>로 된 입력창을 선택하고, 한개, 그 이상의 파일을 선택한 후 한 번에 <form>태그의 데이터와 파일 데이터를 같이 전송하는 방식
2) <form> 데이터와 파일 데이터를 구분해서 전송하는 방식 : 파일은 완전히 별도로 업로드하고, <form>의 데이터는 나중에 전송하는 방식 (앞의 예제)

* 게시물 등록 준비
1) 사용자는 게시물의 제목, 내용, 작성자 등을 작성
2) 첨부파일이 필요한 경우 탐색기에서 원하는 파일을 끌어다 놓음으로 파일을 미리 서버에 업로드 시킴
3) 이후 사용자는 게시물의 등록 버튼을 통해 게시물을 등록
=> 데이터베이스에 추가적인 구조가 필요

* 게시물 등록의 파일 업로드 추가 순서
1) 데이터베이스에 테이블 추가
- 테이블에서 첨부파일의 이름은 업로드 시점에 고유하게 처리되기 때문에 기본키로 사용 가능
- 모든 첨부파일의 정보는 특정 게시물과 관련이 있으므로 bno 칼럼을 생성하고, 이는 외래키로 참조해 사용
- 등록 작업에서 트랜잭션 처리가 필요한 상황이 오게됨, 게시물 등록될 때 기존 board테이블에만 insert되는 것이 아니라, 첨부파일 테이블에도 어떤 게시물이 어떤 첨부파일을 사용하게 되는지 저장해야함

2) 도메인 객체 변화
- BoardVO의 설꼐에 추가적 데이터가 필요, 다른 변수와 달리 String[]으로 작성

3) BoardDAO의 변화
- DAO에는 첨부파일 테이블에 새로운 첨부파일이 추가될 수 있는 기능이 추가됨 (새롭게 생성된 게시물의 번호가 필요)
- 등록 작업은 한 번에 게시물의 테이블인 보드 테이블에 내용이 추가되는 것과 동시에 첨부파일 테이블에도 게시물 번호를 같이 저장하게 됨
- 문제는 보드 테이블의 설계는 게시물의 번호인 bno 칼럼이 'auto_increment'로 설계 되어서 게시물의 등록 시점에 게시물 번호가 생성된다는 점임
=> BoardDAO에 첨부파일 정보를 저장하는 기능을 LAST_INSERT_ID()로 이용 (바로 이전에 등록된 번호(PK를 알아낼 때)를 가져오기 위해서)

4) BoardService의 변경과 트랜잭션의 처리
- 첨부파일 기능이 추가되면서 게시물의 등록은 보드 테이블에 게시물 정보에 대한 insert 작업과, 첨부파일 테이블에 첨부파일의 이름이 함게 등록되는 작업이 진행돼야 함
- BoardDAO의 create()와 addAttach()를 연속으로 사용하기 때문에 트랜잭션을 처리하는 방식으로 변경돼야 함
- 작업 순서는 먼저 게시물을 등록하는 dao.create()를 호출한 후 첨부파일의 이름 배열을 이용해 각각의 파일 이름을 데이터베이스에 추가하는 형태로 구현

5) 게시물 등록을 위한 화면 처리
- 댓글 처리와 마찬가지로 파일 업로드의 기능도 Ajax로 동작하므로, 화면 구성에 변화 필요, 파일은 끌어놓을 수 있고, 업로드 된 파일이 보여지는 부분에 대한 처리가 필요
- 모든 작업은 Ajax를 이용해 처리되므로, 컨트롤러에서는 기존의 방식 그대로 처리

6) 파일 업로드를 위한 jsp 페이지 수정
- 파일을 끌어놓을 수 있는 영역과 업로드 된 파일이 보여지는 영역을 작성
- 기존 <form> 태그 내에 첨부파일을 추가할 수 있는 영역과 업로드 된 파일이 보여질 수 있는 <ul> 태그 생성
- 첨부파일용 템플릿 추가 (파일 아이콘을 보여주도록 작성)
- <li>를 구성할 때 'imgsrc'속성을 보여주는데, 'imgsrc'는 이미지 파일인 경우 썸네일 파일 경로이고, 일반 파일인 경우는 단순히 파일 모양의 이미지를 보여주는 경로

7) 업로드 된 파일 이름의 처리를 위한 JavaScript
- Drag & Drop으로 파일이 업로드 될 때 업로드 과정 : 서버에 업로드 된 파일 이름 => getFileInfo()를 통한 정보 추출 (JavaScript 객체 생성) => handlebars 적용 => HTML 생성 => 화면 적용
- 파일이 업로드 되면 서버에서는 파일의 경로와 이름이 같이 전송됨, 이를 가지고 handlebars의 템플릿을 적용해야 하므로, 템플릿에서 필요한 정보를 JavaScript의 객체로 만드는 작업을 진행
- 파일이 Ajax로 전송되는 부분의 처리를 보면 getFileInfo()함수를 이용해 템플릿에 필요한 객체를 생성, 이후 템플릿을 적용해 온전한 HTML을 구성한 후 첨부된 파일이 보여지는 업로드리스트의 일부로 추가
- getFileInfo()는 별도의 JavaScript 파일로 작성해 처리 (other -> JavaScript Source file 만들기), upload.js는 getFileInfo()의 파라미터로 서버에서 전송된 파일의 이름을 사용
- 해당 파일이 이미지인 경우를 체크하는 checkImageType()을 이용해 써네일 이미지파일의 경로를 계산하거나, 다운로드, 원본 이미지 파일의 경로를 계산
- getFileInfo() 내에 선언된 fileName은 경로나 UUID가 제외된 파일의 이름, imgsrc는 화면상에 보여주는 썸네일 혹은 파일 이미지의 경로, getLink는 화면에서 원본 파일을 볼 수 있는 링크
- 마지막 리턴 값은 정보들을 JavaScript의 객체로 생성해 반환해주고, register.jsp에서 템플릿을 이용해 화면에 보여지도록 함, 작성된 js파일을 register.jsp에 포함시켜줌

8) <form> 태그의 submit 처리
- 최종적인 submit이 일어나게 되면, 서버에는 사용자가 업로드 한 파일의 정보를 같이 전송해 줘야 함, 업로드 된 파일의 이름을 <form> 태그의 내부로 포함시켜서 전송하는 방식을 이용
- 먼저 기본 동작을 막고, 현재까지 업로드된 파일들을 <form>태그의 내부에 input type hidden으로 추가
- 이때 각 파일은 'files[0]'과 같은 이름으로 추가되는데, 이 배열 표시를 이용해 컨트롤러에서는 VO의 files 파라미터를 수집하게 됨
- 모든 파일의 정보를 hidden으로 생성한 후 <form> 데이터의 submit()을 호출해서 서버를 호출, JQuery의 get(0)은 순수한 DOM 객체를 얻어내기 위해 사용

#6. 조회 페이지와 파일 업로드
- 게시물을 조회하는 경우 파일 업로드는 삭제 관련 기능이 삭제되는 대신 등록된 파일을 다운로드 하거나 원본 파일을 볼 수 있는 기능이 제공돼야 함
- 게시물에서 'Light Box'라는 큰 화면으로 게시물에 첨부된 파일을 보는 기능이나, 다운로드 기능이 제공돼야 함

* 순서
1) VO 객체의 조회
- 사용자가 첨부파일이 있는 게시물을 조회하게 되면 기존 조회 화면 아래쪽에는 파일 목록을 볼 수 있어야함
- 처음부터 보드 테이블과 첨부파일 테이블을 조인해 SQL문을 작성해 처리하는 방법과 댓글과 마찬가지로 Ajax를 이용해 현재 게시물의 첨부파일을 별도로 처리하는 방법 2가지가 있음 (예제는 Ajax 이용)
- 성능 관점에서 보면 한 번의 SQL 문으로 여러 정보를 가져오는 방식이 권장되지만 MyBatis에서 한 개의 게시물과 여러 개의 첨부파일에 대한 처리를 진행하기 때문에 복잡해지는 단점이 있음

2) DAO의 처리
- 특정 게시물의 첨부파일을 시간 순서대로 가져오는 SQL문을 작성함

3) Service 처리
- Service와 ServiceImpl은 첨부파일을 조회하는 기능이 추가

4) 컨트롤러 수정
- Ajax로 호출되는 특정 게시물의 첨부파일을 처리하는 메소드를 작성
- 호출 경로는 '/sborad/getAttach/게시물 번호'의 형태가 되고, 리턴 타입은 첨부파일의 문자열 리스트 형태로 작성

5) 조회 화면에서의 처리
- 조회 화면에서는 화면에 게시물의 정보가 정상적으로 처리된 후 Ajax로 호출
- 조회 페이지에서 기존에 업로드 된 파일들이 보여질 수 있는 영역을 작성하고, upload.js 와 handlebars를 설정
- 컨트롤러에서 문자열의 리스트를 반환하기 때문에 JSON 형태의 데이터를 전송하게 되고, getJSON()을 이용해 처리
- 등록 화면 템플릿과 다른 점은 등록 화면에서는 파일 삭제가 가능하지만, 조회 경우 파일 삭제 자체는 불가능 하다는 점

6) 원본 이미지의 조회와 다운로드 처리
- 조회 화면에서 업로드 한 파일을 원본 그대로 확인하거나, 다운로드 할 수 있게 처리를 해야 함
- 일반 파일의 경우 컨트롤러에서 자동으로 MIME 타입을 다운로드 하기 때문에 처리할 것이 없지만, 이미지 파일은 화면이 전환되면서 이미지가 보여지기 때문에 별도의 이벤트 처리가 필요
- 예제는 CSS를 이용해 화면 맨 앞쪽으로 보여지게 처리하고, 일반 파일의 경우 다운로드 할 수 있도록 처리
- 이미지를 보여주기 위해 화면상 숨겨져 있는 <div>를 작성하고, 이미지 파일명을 클릭하면 큰 크기로 보여주게 함
- 이미지 파일인 경우 원본 파일의경로를 특정한 <div>에 <img> 객체로 만들어 넣은 후 해당 <div>를 맨 앞쪽으로 보여주게 처리함
- 사용자가 첨부파일 제목을 클릭한 경우 해당 파일이 이미지인지 체크하면, 화면 이동을 못하도록 prevnet처리
- 현재 클릭한 이미지의 경로를 id 속성값이 'popup_img'인 요소에 추가, 추가 후 화면에 보이도록 JQuery의 show()를 호출하고, 필요한 CSS를 추가
- 화면에 원본 이미지가 보여진 후 다시 클릭하면 이미지가 사라지는 효과 처리

#7. 게시물 수정, 삭제 작업의 파일 업로드
- 첨부파일을 삭제 후 새로운 파일을 업로드 가능, 기존 업로드한 모든 파일의 정보는 삭제하고, 새롭게 첨부파일과 관련된 정보를 넣는 방법

* 순서
1) DAO
- 기존 첨부파일을 삭제하고, 새롭게 추가하는 부분이 들어가므로 SQL 처리
- deleteAttach()는 특정 게시물 번호에 속하는 모든 첨부파일을 삭제, replaceAttach()는 수정된 상태의 파일 이름과, 이미 등록되어 있는 게시물의 번호가 필요

2) 트랜잭션 처리
- 첨부파일 존재 시 게시물의 수정은 '원래 게시물 + 기존 첨부파일 목록삭제 + 새로운 첨부파일 정보 입력'의 3가지 작업이 함께 이뤄져야 하기 때문에 트랜잭션으로 처리

3) 수정 화면의 처리 및 삭제 처리
- 수정은 첨부파일의 정보를 삭제하고, 새롭게 추가하기 때문에 등록 처리 방식과 동일
- 삭제 처리는 데이터베이스의 삭제와 업로드 되었던 첨부파일의 삭제 작업이 같이 진행
- 첨부파일의 삭제는 게시물 삭제 시 기존 첨부파일을 함께 삭제해 주는 것이 좋기 때문에 업로드컨트롤러를 이용해 첨부파일에 대한 삭제 작업 처리 (여러 개의 파일 이름을 받을 수 있도록 String[]로 작성)
- 데이터베이스의 삭제 처리는 ServiceImpl을 통해 이루어짐 (삭제 작업의 경우 첨부파일 테이블이 보드 테이블을 참조하기 때문에 반드시 첨부파일과 관련된 정보부터 삭제하고, 게시글을 삭제함)

4) 삭제 화면의 처리
- Ajax를 이용해 첨부파일의 삭제를 지시하고, <form>방식을 이용해 삭제 진행
- 게시물 삭제를 선택하면 현재 첨부파일의 이름을 배열로 작성해 컨트롤러에 Ajax 방식으로 첨부파일에 대한 삭제를 지시
- 첨부파일의 삭제 이후 바로 <form> 태그를 이용해 데이터베이스의 삭제를 처리할 것이므로 성공이나 실패를 기다리지 않고 removePage를 호출하는 형태로 작성

* 순서 정리
1) 첨부파일의 등록
2) 첨부파일 등록 방식은 크게 <form>, Ajax의 형태가 존재
3) 첨부파일의 반환과 화면 출력
4) 파일 업로드 정보를 테스트한 후 파일 정보를 다시 브라우저로 전송
5) 첨부파일의 저장
6) 실제로 파일 저장 이 경우 고유 파일이름, 경로, 썸네일에 주의해 처리
7) 첨부파일의 조회
8) 첨부파일이 제대로 화면에서 볼 수 있도록 작성, 이미지 파일과 일반 파일을 구분해 큰 화면으로 보거나, 다운로드 할 수 있도록 조치
9) 첨부파일의 삭제
10) 첨부파일이 삭제 될 때 데이터베이스와 관련해 트랜잭션 처리가 필수이고, 파일과 관련해 저장된 파일을 같이 삭제하도록 처리해야 함


