PART3. Ajax 댓글 처리
#1. RestController와 Ajax

* REST 방식이란?
- 하나의 URI는 하나의 고유한 리소스를 대표하도록 설계된다는 개념, 서버에 접근하는 기기의 종류가 다양해 지면서 다양한 기기에서 공통으로 데이터를 처리할 수 있는 규칙
- 특정한 URI는 반드시 그에 상응하는 데이터 자체라는 것을 의미
- '/board/123'은 게시물 중에서 123번이라는 고유한 의미를 가지도록 설계하고, 이에 대한 처리는 GET, POST 방식과 같이 추가적인 정보를 통해 결정

* REST API란?
- 외부에서 위와 같은 방식으로 특정 URI를 통해서 사용자가 원하는 정보를 제공하는 방식
- 최근에 Open API에서 많이 사용되면서 REST방식으로 제공되는 외부 연결 URI를 REST API라고 하고, REST 방식의 서비스 제공이 가능한 것을 'Restful' 하다고 표현

* @RestController (스프링 4버전부터 지원)
- 기존의 특정한 JSP와 같은 뷰를 만들어 내는 것이 목적이 아닌 REST 방식의 데이터 처리를 위해 사용하는 어노테이션
- JSP와 같은 뷰를 만들어 내지 않는 대신에 데이터 자체를 반환, 이때 주로 사용되는 것은 단순 문자열과 JSON, XML 등이 있음
1) 단순 문자열의 경우
- 문자열 데이터는 기본적으로 브라우저에는 'text/html'타입으로 처리
- 클래스 선언부에 @RestController 어노테이션을 이용하고 있는 것은 해당 컨트롤러의 모든 뷰 처리가 JSP가 아니라는 것을 의미
- @RestController 어노테이션이 사용된 클래스의 모든 메소드는 @ResponseBody가 없어도 동일하게 동작(생략되었다고 해도 무방)
- 결과로 반환하는 문자열이 JSP 경로가 아닌 일반 문자열, 실행 후 서버에 전송되는 데이터를 보면 'text/html' 타입의 데이터가 전송되는 것을 확인 할 수 있음
2) 객체를 JSON으로 반환하는 경우
- @RestController의 경우 별도의 처리가 없어도 객체는 자동으로 JSON으로 처리될 수 있음
- 메소드 내부에서 해당 타입의 객체를 생성하고 이를 반환
- 객체를 JSON으로 변환하거나 반대의 작업을 하기 위해서 jackson-databind라이브러리 추가 (pom.xml), JSON을 이용해야 하는 프로젝트에 반드시 필요한 라이브러리
- 실행 후 서버에 전송되는 데이터를 보면 'application/json' 타입의 데이터가 전송되는 것을 확인 할 수 있음
3) 컬렉션 타입의 객체를 반환하는 경우 (List, Map 타입)
- List의 경우 키와 값으로 구성되어 '{}'로 표현, Map의 경우는 '키 : 값' 형태로 출력

* ResponseEntity 타입
- @RestController는 별도의 뷰를 제공하지 않는 형태로 서비스를 실행하기 때문에 결과 데이터가 예외적인 상황에서 문제가 발생할 수 있음
- 웹의 경우 HTTP 상태(status) 코드가 이러한 정보를 나타내는 데 사용됨
- 스프링에서 제공되는 ResponseEntity 타입은 개발자가 직접 결과 데이터 + HTTP의 상태 코드를 직접 제어할 수 있는 클래스
- 404나 500같은 HTTP 상태 코드를 전송하고 싶은 데이터와 함께 전송할 수 있기 때문에 좀 더 세밀한 제어가 필요한 경우에 사용
- @RestController를 이용해 결과 데이터만을 서버에서 제공하는 방식은 데이터를 이용하는 클라이언트 측에서의 기능이 많아지는 경우에 사용 
- Androit나 iPhone과 같은 모바일 환경에서 서버의 데이터를 이용하거나 HTML5나 Ajax등을 이용하는 경우에 많이 사용

* HTTP 상태 코드
1) 100번대 : 현재 데이터의 처리 중인 상태
- 100 : 데이터의 일부를 서버가 받은 상태
2) 200번대 : 정상적인 응답
- 200 : 에러 없이 정상 처리
- 204 : 정상 처리되었으나 서버에서 보내줄 데이터가 없음
3) 300번대 : 다른 URL 처리
- 301 : 요청된 페이지가 새 URL로 변경되었음
- 304 : 이미 기존의 데이터와 변경된 것이 없음
4) 400번대 : 서버에서 인식할 수 없음
- 400 : 전송된 Request에 문제가 있어 서버가 인식할 수 없음
- 403 : 서버에서 허락되지 않음
- 404 : URL에 해당하는 자원을 찾을 수 없음
- 406 : 전송 방식이 허락되지 않음(REST에서 자주 발생)
5) 500번대 : 서버 내부의 문제
- 500 : 서버에서 처리 시 문제가 발생
- 502 : 게이트웨이나 프록시 상태의 문제(과부화 등)
- 503 : 일시적인 과부하나 서비스 중단 상태
- 504 : 지정된 처리시간이 지나 처리되지 못함

#2. 댓글 처리와 REST (URI + Http 메소드(get, post, put....)을 이용해 작업 처리)

* REST 방식을 사용하는 원칙
1) URI가 원하는 리소스를 의미 : 특별한 경우가 아니라면 영어에서 복수형의 형태로 작성하는 것이 일반적
2) URI에는 식별할 수 잇는 데이터를 같이 전달하는 것이 일반적 : HTTP의 전송 방식(method)이 실제 작업의 종류를 의미 (작업대상/PK 와 같은 방식의 접근이 무난)
- /board/123 : 123번 게시물 조회
- /board/123/replies/456 : 123번 게시물의 댓글 456번을 조회
- /board/123/456 : 123번 게시물의 댓글 456번 조회
- /board/  : 신규 작성 입력 페이지 조회

* 전송방식의 예
- GET (/board/123) : 자료의 조회
- DELETE (/board/123) : 자료의 삭제
- POST (/board 혹은 /board/new) + 데이터 : 신규 자료의 등록
- PUT (/board/123) + 데이터 : 신규 자료의 수정 혹은 등록
- PATCH : 간혹 PUT 방식 대용으로 사용함

* Advanced REST Client를 이용한 테스트
- REST 방식은 다양한 디바이스로부터 서버에 데이터와 작업을 요청하고 결과를 받는다는 점에서 유용하지만 일반적인 웹 페이지와는 달리 화면을 제작하지 않는 형태로 처리되므로 결과를 체크하면서 개발하기에는 힘듦
- 결과를 테스트할 수 있는 Advanced REST Client를 사용

* REST와 Ajax
- 웹을 통해 작업할 때 REST방식이 가장 많이 쓰이는 형태는 Ajax와 같이 결합된 형태
- Ajax는 브라우저에 대화형으로 서버와 데이터를 주고받는 형태의 메시지 전송 방식, 화면의 전환이나 깜빡임 없이 서버에서 데이터를 받는 방법(비동기화된 자바스크립트와 XML), 예 : 구글의 지도나 포털 사이트 자동완성 기능
- 비동기화의 의미는 결과의 데이터를 기다리는 방식이 아닌 결과를 통보받는 형식이라고 볼 수 있음 
- 대부분 프로그래밍은 특정 로직을 호출 -> 결과를 받아 다음 로직을 실행하는 방식,  비동기화 방식은 로직을 호출 -> 결과를 기다리지 않고 결과가 통보될 때 실행할 로직을 지정하는 방식
- 동기화 방식은 순차적인 일을 실행하는데 적합, 비동기 방식은 일을 처리한 결과를 기다리지 않고 흐름이 지속, 처리된 일의 결과를 통보받은 형태로 처리됨
- REST방식이 데이터를 호출하고 사용하는 방식이라면 Ajax는 실제로 그를 이용하는 수단에 가까움

* Ajax의 특징
- 브라우저의 화면 전환이 없기 때문에 사용자 경험 측면에서 좋음
- 서버에서 화면에 필요한 모든 데이터를 만드는 대신 서버는 필요한 데이터만 전달하기 때문에 개발의 무게 중심이 브라우저 쪽으로 많이 배분된다는 점
- Ajax의 시작 시점에는 서버와 메시지 전달에 있어 일반 텍스트나 XML을 주로 사용했지만 최근에는 JSON 형태의 데이터를 사용하는 경우도 증가

* REST 방식 구현 순서 (댓글 기능)
1) 전달 방식과 처리 방식의 결정 - 해당하는 컨트롤러를 먼저 작성하고, 그에 맞는 URI를 결정
- /replies/all/123 (GET 방식) : 게시물 123번의 모든 댓글 리스트
- /replies/ + 데이터 (POST 방식) : 새로운 댓글 추가
- /replies/456 + 데이터 (PUT/PATCH 방식) : 456 댓글 수정
- /replies/456 (DELETE 방식) : 456 댓글 삭제
2) 데이터 전송 방식의 결정
- REST 방식으로 원하는 데이터를 서비스 받는 경우는 주로 웹과 모바일, 최근 모바일이 발전하면서 REST 방식으로 데이터를 제공하는 일이 점차 늘어남
- 모바일이나 외부에서 네트워크를 이용해 원하는 데이터만 주고 받는 형태로 많이 사용하기 때문에 데이터의 전송 역시 XML이나 JSON을 사용하는 경우가 많음
- 웹 화면에서 전송되는 경우라면 <form> 태그를 이용하지만 기본적으로 REST에서 많이 사용하는 JSON 기준으로 작성
3) 댓글 테이블 설정
4) 댓글 도메인 객체 설계
5) DAO 인터페이스, XML Mapper, DAOImpl, Service, ServiceImpl 작성

#3. REST 방식의 Controller 작성

* 각 URI, 전송방식 및 설명
1) /replies/ + JSON 데이터 - POST - 새로운 댓글 등록
2) /replies/ + JSON 데이터 - PUT, PATCH - 댓글 수정
3) /replies/댓글번호 - DELETE - 댓글 삭제

* REST 방식의 처리에서 사용하는 어노테이션
1) @PathVariable - URI의 경로에서 우너하는 데이터를 추출하는 용도로 사용
2) @RequestBody - 전송된 JSON 데이터를 객체로 변환해 주는 어노테이션으로 @ModelAttribute와 유사한 역할을 하지만 JSON 에서 사용된다는 점이 차이

* 댓글 처리 순서
1) 등록 처리
- '/replies' URI로 처리되고, POST 방식으로 전송
- register()의 리턴 타입은 ResponseEntity<String>으로 설계, 만일 새로운 댓글을 등록하는데 실패하면 try ~ catch에 선언되었듯이 예외의 원인 메시지를 전송하고, BAD_REQUEST를 결과로 전송
- 데이터 전송방식은 JSON 포맷을 이용할 것이므로 이를 처리하는 @RequestBody 어노테이션 필요
- Advanced REST Client로 테스트
2) 특정 게시물의 전체 댓글 목록의 처리 (전체 댓글 목록 조회 기능)
- 댓글 목록은 GET방식으로 처리돼야 하고, 반드시 특정 게시물의 번호(bno)를 필요
- URI 내의 경로 {bno}를 활용하는데 {bno}는 메소드의 파라미터에서 @PathVariable("bno")로 활용됨
- Advanced REST Client로 테스트
3) 수정 처리
- REST 방식에서 update 작업은 PUT, PATCH 방식을 이용해 처리, 일반적으로 전체 데이터를 수정하는 경우에는 PUT, 일부 데이터를 수정하는 경우에는 PATCH를 이용 (여기선 PUT 방식 사용)
- Advanced REST Client로 테스트
4) 삭제 처리 (DETETE 방식 이용)
- 삭제 처리는 PUT과 유사, 추가적인 데이터가 없다는 부분때문에 더 간단히 처리 가능
- Advanced REST Client로 테스트
5) 댓글 페이징 처리
- REST 방식의 경우 전통적인 Model 객체에 데이터를 담지 않고 객체를 처리할 수 있기 때문에 메소드의 파라미터 처리가 조금 달라지긴 해도 간단하게 처리 가능
- Reply DAO에 listPage(), count()기능 추가, 화면에 페이징 처리를 하기 위해 반드시 해당 게시물의 댓글 수가 필요하므로 count()를 작성
- Controller에서 두 개의 @PathVariable을 이용해서 처리하도록 작성 ('/replies/게시물 번호/페이지 번호', GET 방식의 처리)
- listPage()는 '/게시물 번호/페이지 번호'를 패턴으로 처리, Ajax로 호출될 것이므로 Model을 사용하지 못함, 전달해야 하는 데이터들을 담기 위해 Map 타입의 객체를 별도로 생성해야 함
- Map 데이터는 페이징 처리된 댓글의 목록(list), PageMaker 클래스의 객체(pageMaker)를 담음, 게시물의 페이징과 달리 댓글은 페이지 당 보여주는 수가 변경되는 경우는 드물기 때문에 10,20,50으로 결정하는게 일반적

#4. 화면에서의 Ajax 호출
- @RestController를 이용하는 경우 데이터만 만들어져 전송되기 때문에 사실상 개발의 대부분은 이를 처리하는 화면으로 집중됨
- 앱에서는 HTTP 방식으로 데이터를 주고받을 수 있는 라이브러리 등을 활용해 데이터 처리, 웹에서는 Ajax 사용

* 개발의 순서 결정 (Ajax를 이용하는 댓글 처리는 개발 대부분이 화면에서의 처리가 많으므로 간단한 페이지를 만들어 결과 데이터의 처리를 연습)
1) 특정 게시물을 미리 지정하고, 전체 댓글의 목록을 가져와 출력하는 기능을 작성
2) 댓글을 입력할 수 있는 화면 구성, 이를 이용해 새로운 댓글 추가 (전체 목록을 우선 구현하는 이유는 새로운 댓글이 추가된 후 자동으로 전체 댓글을 갱신하도록 작성해서 볼 수 하기 위해)
3) 댓글의 목록에서 특정 게시물을 선택해 수정, 삭제 작업이 이루어지는 화면 구성
4) 댓글 삭제 작업 진행 후, 등록과 마찬가지로 전체 목록을 갱신해서 댓글이 사라지는 결과를 확인할 수 있게 함
5) 댓글 수정 작업 진행 후, 목록이 갱신되어 겨로가를 볼 수 있게 함
6) 댓글에 대한 페이징 진행

* 테스트를 위한 컨트롤러와 JSP
- 테스트를 위한 JSP를 구성하기 위해 컨트롤러에 URI를 등록해야 하는데 HomeController를 이용해 URI를 처리할 수 있도록 메소드 추가
- JSP에서 가장 만저 해야 할 일은 JQuery 라이브러리를 사용할 수 있게 처리하는 것

* 전체 댓글 목록의 테스트
- 테스트용 댓글을 작성, JSP에서 JQuery를 이용해 만들어 놓은 Controller 호출
- @RestController의 경우 객체를 JSON 방식으로 전달하기 때문에 JQuery를 이용해 호출할 때 getJSON()을 이용, 호출된 결과는 테스트 댓글의 갯수가 출력
** $.getJSON 이란?
- 전달받은 주소로 GET 방식의 HTTP 요청을 전송하여, 응답으로 JSON 파일을 전송받음

* 전체 댓글 목록 출력
- Ajax로 호출된 목록에 대해 루프를 돌면서 <li> 태그를 생성, 각 <li> 마다 댓글의 번호와 내용이 출력되도록 함
- <li> 태그의 속성으로 사용한 'data-rno'는 'data-'로 시작되는 속성은 이름이나 개수에 관계없이 태그 내에서 자유롭게 사용할 수 있는 속성이므로 id나 name 속성을 대신해 사용하기 편리함
- 전체 목록을 갱신하는 부분은 여러 번 사용되기 때문에 별도의 함수로 만들어 처리하는 것이 좋음

* 댓글 등록 화면 및 테스트
- test.jsp 에서 댓글 등록 부분을 구성하고, 등록 이후 작성된 함수를 이용해 추가된 댓글을 볼 수 있게 작성
- JQuery를 이용해서 $.ajax()를 통해 서버를 호출, 전송하는 데이터는 JSON으로 구성된 문자열을 사용하고, 전송 받은 결과는 단순 문자열, $.ajax를 이용해 다양한 옵션으로 구성
** $.ajax()
- Ajax를 이용하여 개발을 손쉽게 할 수 있도록 미리 여러 가지 기능을 포함해 놓은 개발 환경을 Ajax 프레임워크
- 그중에서도 현재 가장 널리 사용되고 있는 Ajax 프레임워크는 바로 jQuery
*** $.ajax() 메소드에서 사용할 수 있는 대표적 옵션
- url : 클라이언트가 요청을 보낼 서버의 URL 주소
- data : HTTP 요청과 함께 서버로 보낼 데이터
- type : HTTP 요청 방식(GET, POST 등)
- dataType : 서버에서 보내줄 데이터 타입
- success : 응답이 성공일때 호출되는 Callback 함수
- error : 요청결과가 실패일때 호출되는 Callback 함수
- complete : success 나 error Callback 함수가 수행된 후 실행되는 함수
- 서버가 result로 응답해줌

* JQuery의 $.post를 사용하지 않는 이유
- $.post()의 경우 일반적 데이터 전송 방식에 적합함
- 호출에 사용된 데이터를 살펴보면 일반적인 <form> 처리된 데이터와 동일한 것을 볼 수 있음, 이렇게 전송될 경우 Controller에서는 @RequestBody 어노테이션이 제대로 처리되지 못하게 되는 문제가 생김
- @RequestBody의 경우 JSON으로 전송된 데이터를 VO 타입의 객체로 변환해 주는 역할을 하는데, 이때 데이터는 일반적 데이터가 아니라 JSON으로 구성된 문자열 데이터임
- $.ajax일때는 데이터 전송 할 때 HTTP 헤더 정보에 'application/json'이라고 명시한 상태에서 데이터를 전송함, 전송된 데이터는 JSON.stringify()를 이용해 JSON 데이터를 구성해 전송하므로 문자열이 전송됨
** JSON.stringify()
- JSON 객체를 String 객체로 변환시켜 주는 메소드

* 댓글 조회 및 수정, 삭제
- 수정 버튼에 대한 이벤트 처리
- 댓글의 각 항목을 의미하는 <li>의 경우 Ajax의 통신 후 생기는 요소들이기 때문에 이벤트 처리 할 때 기존에 존재하는 <ul>을 이용해 이벤트 등록
- 이후 이벤트는 위임 방식으로 전달, class 속성값이 'replyLi'로 된 요소 밑의 <button>을 찾아 이벤트 전달
- JQuery의 이벤트는 아직 존재하지 않는 요소에 이벤트를 위임해주는 편리한 기능이 있으므로, 한 번에 모든 목록에 대한 클릭 이벤트를 처리할 수 있음
- 각 <li>의 'data-rno' 속성의 값을 추출하고, 댓글의 내용을 추출해 경고창을 통해 보여줌
- 수정, 삭제를 위해 <div>를 작성 후, JQuery로 간단히 화면에 보여주고 감추는 기능을 구현할 수 있음
- 작성된 <div>는 평상시에 보이지 않도록 하고, 수정버튼을 눌렀을때만 보이도록 하기 위해 스타일 적용(display: none;)
- 수정 버튼 눌렀을때 댓글의 번호와 내용을 <div>를 이용해 보여지도록 JQuery를 이용해 수정
- 삭제 호출시 삭제 버튼을 누르면 삭제가 되게 처리, 삭제는 HTTP의 DELETE 방식으로 동작하도록 설계
- POST방식과 마찬가지로 JSON 타입의 데이터를 전송해야 함, 삭제 작업 이후 보여지고 있는 <div>를 안 보이게 처리(hide)한 후 다시 전체 목록을 가져오는 함수 호출
- 14번 댓글을 선택하면 화면에는 <div>가 보여지면서 삭제버튼이 보이게 되고, 삭제버튼을 선택하면 Ajax를 통해 서버에서 삭제 작업을 진행한 후 경고창을 통해 알려줌, 이후 목록함수를 호출해 화면상의 목록을 갱신하게됨
- 수정 작업은 삭제와 유사하지만 URI 경로는 같이 사용하고, 데이터가 전송되는 부분은 PUT 방식 사용

* 댓글 페이징 처리
- 댓글 페이징 처리는 '/replies/게시물 번호/페이지 번호' 로 이루어짐, 결과는 댓글 목록에 해당하는 list 데이터와 페이지 구성에 필요한 pageMaker 데이터로 구성
- getPageList() 함수는 페이지 번호를 입력받고, JQuery의 getJSON()을 이용해 가져온 데이터를 처리
- list 데이터를 이용해 댓글 내용들을 표시하고, 페이징 처리를 위해 만들어진 pageMaker 데이터를 이용해 printPaging()을 호출
 printPaging()은 JavaScript 객체인 pageMaker를 이용해 화면에 페이지 번호를 출력, JSP가 처음 동작하면 1페이지의 댓글을 가져오도록 코드 수정

* 페이지 번호 이벤트 처리
- 각 페이지 번호에 대한 클릭 이벤트를 처리하도록 함, 이때 <a> 태그의 내용 중 페이지 번호를 추출해 Ajax 호출을 처리
- event.preventDefault()는 <a href="> 태그의 기본 동작인 페이지 전환을 막는 역할, 화면의 이동을 막은 후 현재 클릭된 페이지의 번호를 얻어내고, 이 번호로 getPageList()를 호출
- replyPage는 클릭되는 페이지 번호를 의미하고, 수정이나 삭제 작업에 다시 목록 페이지를 갱신할 때 필요한 정보이므로 별도 변수로 처리

#5. 게시물 관리의 댓글 적용
- Ajax 작업은 화면에서의 구성과 처리에 많은 시간이 들기 때문에 서버에서 만들어지는 데이터의 처리를 우선적으로 하고, 화면을 구성하는 것이 좋음
- 조회 화면에 Ajax 기능을 적용해 특정 게시물에 댓글을 처리하는 것을 구현
- 조회 화면 하단에 있는 '댓글 보기' 버튼을 통해 해당 게시물에 속한 댓글의 목록을 가져올 수 있음

* 조회 화면의 수정
- 기존 조회 화면에서 댓글 관련 기능을 추가해야 하기 때문에 HTML의 변경이 필요, 추가되는 영역은 댓글을 입력하는 부분, 댓글 목록을 보여주는 부분, 댓글의 페이징 처리임

* handlebars를 이용한 템플릿
- 댓글 목록 출력은 <li>가 반복적으로 구성되고, 이를 <ul>태그의 내용물로 추가하는 방식으로 동작하기때문에 코드가 복잡하고 지저분함 => JavaScript의 템플릿을 적용하여 좀 더 깔끔하게 처리
- JavaScript 템플릿은 '만들어진 HTML 코드에 데이터(객체)를 넣어 찍어내는 틀'
- 약간의 로직을 지원하는데 제어문이나 루프 등의 처리 기능을 가지고 있음
- helper라는 기능을 이용해 데이터의 상세한 처리에 필요한 기능들을 처리, 기능이 없는 경우 registerHelper()를 이용해 사용자가 새로운 기능을 추가할 수 있음
** 템플릿의 장점
1) 데이터와 뷰를 분리해서 처리 - 복잡한 HTML 태그를 이용해 데이터를 구성하는 경우 문자열로 작성되는 결과를 알아보기 어려움
2) 템플릿을 변경하기 쉬움 - 템플릿의 내용물만을 변경하기 때문에 유지보수에 더 편리하게 사용할 수 있음
3) 템플릿의 재사용이 용이 - 템플릿만을 별도로 관리하면 필요할 때 별도의 코드를다시 작성하지 않고도 적용이 가능하기 때문에 생산성을 높일 수 있음

* 댓글 목록 처리
- handlebars를 사용해 화면에 반복적으로 처리되는 템플릿 코드를 처리할 수 있고, 서버에서는 댓글의 목록과 댓글의 리스트 데이터를 한 번에 전송해 줄 수 있음
- 가장 먼저 댓글을 페이징 처리해서 화면에 목록을 보여주는 작업을 해야함
- getPage()는 특정한 게시물에 대한 페이징 처리를 위해 호출되는 함수, 내부적으로 JQuery를 이용해 JSON 타입의 데이터를 처리
- var bno는 JSP에 처리되는 문자열로 해당 게시물의 번호를 의미, replyPage는 수정이나 삭제 작업 이후 사용자가 보던 댓글의 페이지 번호를 가지고 다시 목록을 출력하기 위해 유지되는 데이터
- getPage()는 페이지 번호를 파라미터로 전달받고, JQuery의 getJSON()을 이용해 댓글의 목록 데이터를 처리
- 댓글 목록 데이터는 'pagemaker'와 'list'로 구성되므로 printPagnig()과 printData()에서 처리

* 댓글 목록의 이벤트 처리
- 최초로 댓글의 1페이지를 가져오는 작업은 사용자가 화면상에서 replies List 라는 버튼을 클릭했을 때 동작하도록 설계

* 댓글의 펭징의 이벤트 처리
* 새로운 댓글의 등록
- 등록이 완료된 후 1페이지의 댓글 목록을 보여주는 작업으로 이루어짐
- JSON으로 전송하기 위해 별도의 HTTP의 헤더 정보를 추가하고 전송
- 서버에서 등록 처리에 대한 결과를 문자열로 받고, 이를 보여주고 나서 사용자의현재 페이지 번호는 1페이지로 변경하고, 댓글의 페이지를 조회

* 수정과 삭제를 위한 Modal 창
- Modal 창이란 팝업과 유사하지만 다른 작업을 할 수 없도록 제한된 팝업, 이를 위해 별도의 div를 작성

* 각 댓글 버튼 이벤트 처리
- 댓글의 버튼을 클릭해서 처리하는 부분에는 위의 Modal창 <div>의 내용물만을 처리하는 부분만 존재하고, 화면에 나타나게 하는 처리는 Bootstrap이 제공하는 부분을 그대로 사용

* 수정과 삭제 처리
- 수정이나 삭제의 작업 이후 현재 사용자가 보던 댓글 목록 페이지를 유지하는 것이 중요
- 수정 작업의 처리는 HTTP의 PUT 방식을 통해 처리, 삭제 처리는 HTTP의 DELETE 방식을 통해 처리

* 정리
- Ajax의 처리는 서버와 화면의 작업을 철저히 구분하고, 각 작업에 대한 테스트를 진행하는 것이 필수, Ajax는 눈에 안 보이는 형태로 데이터를 주고받기 때문에, 반드시 브라우저에서 개발자 도구를 이용해 확인할 수 있도록 개발
* 작업 순서
1) @RestController를 이용하는 컨트롤러의 작성과 Advanced Rest Client를 이용한 테스트 작업을 진행
2) Ajax를 테스트할 수 있는 환경을 만들고, 서버와의 통신을 확인
3) 화면에서 처리되어야 하는 DOM 구조와 이벤트에 대한 연습 진행
4) 최종적으로 실제 결과물에 Ajax 처리 결과를 반영









